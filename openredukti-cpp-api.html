
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>OpenRedukti C++ API &#8212; OpenRedukti Alpha documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="OpenRedukti Scripting With Ravi" href="openredukti-ravi-api.html" />
    <link rel="prev" title="Pything bindings: redukti package" href="pyredukti-api.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="openredukti-c-api">
<h1>OpenRedukti C++ API<a class="headerlink" href="#openredukti-c-api" title="Permalink to this headline">¶</a></h1>
<p>This document described the C++ API that is available to programmers.</p>
<div class="section" id="basics">
<h2>Basics<a class="headerlink" href="#basics" title="Permalink to this headline">¶</a></h2>
<p>The OpenRedukti C++ API is designed to be fairly simple to use. While OpenRedukti uses C++ templates internally, these are not exposed at
a user level. The API is presented as a simple set of virtual classes and functions.</p>
<p>OpenRedukti uses a bunch of data types defined using Google Protocol Buffers. These reduce the need to manually maintain data types
and greatly improve the ability to make rapid changes to the codebase.</p>
</div>
<div class="section" id="namespace">
<h2>Namespace<a class="headerlink" href="#namespace" title="Permalink to this headline">¶</a></h2>
<p>All components live in the namespace <code class="docutils literal notranslate"><span class="pre">redukti</span></code>.</p>
</div>
<div class="section" id="about-this-document">
<h2>About this document<a class="headerlink" href="#about-this-document" title="Permalink to this headline">¶</a></h2>
<p>The description of the C++ classes below focuses on the API - hence all other aspects have been removed.</p>
</div>
<div class="section" id="common-enums">
<h2>Common Enums<a class="headerlink" href="#common-enums" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;enums.pb.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>For reasons of efficiency all internal data structures use integer codes rather than
strings for values. Most of the enums used are defined in the protocol buffers definition file
<a class="reference external" href="https://github.com/redukti/OpenRedukti/blob/master/proto/redukti/enums.proto">enums.proto</a>.</p>
<dl class="simple">
<dt>redukti::Currency</dt><dd><p>Defines currency codes</p>
</dd>
<dt>redukti::IsdaIndex</dt><dd><p>Defines commonly used ISDA Index names</p>
</dd>
<dt>redukti::IndexFamily</dt><dd><p>Originally defined families of indices; now it represents a grouping for curves</p>
</dd>
<dt>redukti::DayCountFraction</dt><dd><p>Defines supported ISDA Day Count Fractions</p>
</dd>
<dt>redukti::CompoundingMethod</dt><dd><p>Defines compounding methods; compatible with FpML.</p>
</dd>
<dt>redukti::BusinessCenter</dt><dd><p>Defines commonly used ISDA codes for business centers. These are used to derive holiday calendars.</p>
</dd>
<dt>redukti::BusinessDayConvention</dt><dd><p>Defines ISDA specified business day conventions.</p>
</dd>
<dt>redukti::Tenor</dt><dd><p>Defines a tenor period such as 1M or 1Y. The codes are designed so that larger terms have higher codes.</p>
</dd>
<dt>redukti::PeriodUnit</dt><dd><p>Defines the unit in which a period is measured, e.g. Days or Months, etc.</p>
</dd>
<dt>redukti::RollConvention</dt><dd><p>Defines ISDA specified roll conventions for calculating periods for interest rate streams.</p>
</dd>
<dt>redukti::JointCalendarRule</dt><dd><p>Defines how multiple business centers are to be combined for the purposes of computing holidays.</p>
</dd>
<dt>redukti::InterpolatorType</dt><dd><p>Defines the supported interpolation methods.</p>
</dd>
<dt>redukti::CurveGroup</dt><dd><p>Defines curve group ids for the purposes of grouping curves used in pricing.</p>
</dd>
<dt>redukti::CurveType</dt><dd><p>CurveType identifies how the curve operates on its input</p>
</dd>
<dt>redukti::IRRateType</dt><dd><p>Defines the type of value being used in a curve definition.</p>
</dd>
<dt>redukti::PricingCurveType</dt><dd><p>Defines the usage of a curve in a pricing scenario.</p>
</dd>
<dt>redukti::MarketDataQualifier</dt><dd><p>Defines the type of Market Data being used.</p>
</dd>
<dt>redukti::MaturityGenerationRule</dt><dd><p>Defines the rule name for generating maturities of instruments in a curve.</p>
</dd>
</dl>
</div>
<div class="section" id="date-type">
<h2>Date type<a class="headerlink" href="#date-type" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;date.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>Dates are used extensively in OpenRedukti. To make it efficient to manipulate dates an integer representation of a Date is
chosen. The date library is based upon:</p>
<ul class="simple">
<li><p><a class="reference external" href="http://howardhinnant.github.io/date_algorithms.html">Date Algorithms by Howard Hinnant</a>.</p></li>
<li><p>The date implementation in QuantLib.</p></li>
</ul>
<p>The following key types are defined:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// This class provides a Period (length + PeriodUnit) class</span>
<span class="c1">// and implements a limited algebra.</span>
<span class="c1">// Must be standard layout for C compatibility</span>
<span class="k">class</span> <span class="nc">Period</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="c1">// Construct a period from length and unit</span>
   <span class="n">Period</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">PeriodUnit</span> <span class="n">unit</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Default constructor : 0D period</span>
   <span class="n">Period</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">int</span> <span class="nf">length</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">PeriodUnit</span> <span class="nf">units</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Period</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Normalisation converts weeks to days and</span>
   <span class="c1">// years to months</span>
   <span class="n">Period</span> <span class="nf">normalised</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Converts a tenor to period representation</span>
   <span class="c1">// Must be updated if definition of Tenor changes.</span>
   <span class="k">static</span> <span class="n">Period</span> <span class="nf">tenor_to_period</span><span class="p">(</span><span class="n">Tenor</span> <span class="n">tenor</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">Weekday</span> <span class="p">{</span>
   <span class="n">Sunday</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">Monday</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">Tuesday</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">Wednesday</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">Thursday</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">Friday</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
   <span class="n">Saturday</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
   <span class="n">Sun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">Mon</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">Tue</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">Wed</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">Thu</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">Fri</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
   <span class="n">Sat</span> <span class="o">=</span> <span class="mi">6</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Month names</span>
<span class="k">enum</span> <span class="n">Month</span> <span class="p">{</span>
   <span class="n">January</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">February</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">March</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">April</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">May</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
   <span class="n">June</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
   <span class="n">July</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
   <span class="n">August</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
   <span class="n">September</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
   <span class="n">October</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
   <span class="n">November</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
   <span class="n">December</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
   <span class="n">Jan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">Feb</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">Mar</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">Apr</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">Jun</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
   <span class="n">Jul</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
   <span class="n">Aug</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
   <span class="n">Sep</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
   <span class="n">Oct</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
   <span class="n">Nov</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
   <span class="n">Dec</span> <span class="o">=</span> <span class="mi">12</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Date type. Uses an int to</span>
<span class="c1">// represent a serial number.</span>
<span class="c1">// this implementation is immutable - hence</span>
<span class="c1">// thread-safe.</span>
<span class="k">typedef</span> <span class="kt">int32_t</span> <span class="n">Date</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">YearMonthDay</span> <span class="p">{</span>
   <span class="kt">short</span> <span class="n">y</span><span class="p">;</span>
   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">m</span><span class="p">;</span>
   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Returns number of days since civil 1899-12-31.  Negative values indicate</span>
<span class="c1">//    days prior to 1899-12-31.</span>
<span class="c1">// Preconditions:  y-m-d represents a date in the civil (Gregorian) calendar</span>
<span class="c1">//                 m is in [1, 12]</span>
<span class="c1">//                 d is in [1, last_day_of_month(y, m)]</span>
<span class="c1">//                 y is &quot;approximately&quot; in</span>
<span class="c1">//                   [numeric_limits&lt;Int&gt;::min()/366,</span>
<span class="c1">//                   numeric_limits&lt;Int&gt;::max()/366]</span>
<span class="c1">//                 Exact range of validity is:</span>
<span class="c1">//                 [civil_from_days(numeric_limits&lt;Int&gt;::min()),</span>
<span class="c1">//                  civil_from_days(numeric_limits&lt;Int&gt;::max()-719468+25569)]</span>
<span class="c1">// Notes: The original algorithm has been modified to make</span>
<span class="c1">// the serial date match Excel dates. This is done by making the start</span>
<span class="c1">// date 31/Dec/1899 rather than 1/Jan/1970.</span>
<span class="k">constexpr</span> <span class="n">Date</span> <span class="nf">make_date</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">d</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="k">constexpr</span> <span class="n">Date</span> <span class="nf">make_date</span><span class="p">(</span><span class="n">YearMonthDay</span> <span class="n">ymd</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Returns year/month/day triple in civil calendar</span>
<span class="c1">// Preconditions:  z is number of days since 1899-12-31 and is in the range:</span>
<span class="c1">//                   [numeric_limits&lt;Int&gt;::min(),</span>
<span class="c1">//                   numeric_limits&lt;Int&gt;::max()-719468+25569].</span>
<span class="c1">// Notes: The original algorithm has been modified to make</span>
<span class="c1">// the serial date match Excel dates. This is done by making the start</span>
<span class="c1">// date 31/Dec/1899 rather than 1/Jan/1970.</span>
<span class="k">constexpr</span> <span class="n">YearMonthDay</span> <span class="nf">date_components</span><span class="p">(</span><span class="n">Date</span> <span class="n">z</span><span class="p">);</span>

<span class="c1">// Day of the year, where Jan 1 is 1, Jan 2 is 2, Feb 1 is 32 and so on.</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">day_of_year</span><span class="p">(</span><span class="n">YearMonthDay</span> <span class="n">ymd</span><span class="p">);</span>

<span class="c1">// Returns day of week in civil calendar [0, 6] -&gt; [Sun, Sat]</span>
<span class="c1">// Preconditions:  z is number of days since 1899-12-31 and is in the range:</span>
<span class="c1">//                   [numeric_limits&lt;Int&gt;::min(), numeric_limits&lt;Int&gt;::max()-4].</span>
<span class="c1">// Notes: The original algorithm has been modified to make</span>
<span class="c1">// the serial date match Excel dates. This is done by making the start</span>
<span class="c1">// date 31/Dec/1899 rather than 1/Jan/1970.</span>
<span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">weekday</span><span class="p">(</span><span class="n">Date</span> <span class="n">z</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// Preconditions: m is in [1, 12]</span>
<span class="c1">// Returns: The number of days in the month m of common year</span>
<span class="c1">// The result is always in the range [28, 31].</span>
<span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="nf">last_day_of_month_common_year</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">m</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// Returns: true if y is a leap year in the civil calendar, else false</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">is_leap</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// Preconditions: m is in [1, 12]</span>
<span class="c1">// Returns: The number of days in the month m of year y</span>
<span class="c1">// The result is always in the range [28, 31].</span>
<span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="nf">last_day_of_month</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">m</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// Add/subtract periods from dates, both invoke advance() defined below</span>
<span class="k">extern</span> <span class="n">Date</span> <span class="nf">add</span><span class="p">(</span><span class="n">Date</span> <span class="n">date</span><span class="p">,</span> <span class="k">const</span> <span class="n">Period</span> <span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">Date</span> <span class="nf">sub</span><span class="p">(</span><span class="n">Date</span> <span class="n">date</span><span class="p">,</span> <span class="k">const</span> <span class="n">Period</span> <span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// Adds or subtracts a period from a date</span>
<span class="c1">// For handling month periods it ensures that the day stays the same if possible,</span>
<span class="c1">// but if not (e.g. no 29th Feb in final date) then the day is adjusted to fit in the month</span>
<span class="c1">// When handling year periods, the day and month are kept the same if possible</span>
<span class="c1">// or adjusted as above.</span>
<span class="k">extern</span> <span class="n">Date</span> <span class="nf">advance</span><span class="p">(</span><span class="n">Date</span> <span class="n">date</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">PeriodUnit</span> <span class="n">units</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// Construct an end of month date for the</span>
<span class="c1">// given year and month</span>
<span class="k">constexpr</span> <span class="n">Date</span> <span class="nf">end_of_month</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">m</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// Test whether given date is the calendar end of the month</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">is_end_of_month</span><span class="p">(</span><span class="n">YearMonthDay</span> <span class="n">ymd</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// Preconditions: x &lt;= 6 &amp;&amp; y &lt;= 6</span>
<span class="c1">// Returns: The number of days from the weekday y to the weekday x.</span>
<span class="c1">// The result is always in the range [0, 6].</span>
<span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="nf">weekday_difference</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">y</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// Preconditions: wd &lt;= 6</span>
<span class="c1">// Returns: The weekday following wd</span>
<span class="c1">// The result is always in the range [0, 6].</span>
<span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="nf">next_weekday</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">wd</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// Preconditions: wd &lt;= 6</span>
<span class="c1">// Returns: The weekday prior to wd</span>
<span class="c1">// The result is always in the range [0, 6].</span>
<span class="kr">inline</span> <span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="nf">prev_weekday</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">wd</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// next given weekday following or equal to the given date</span>
<span class="c1">// E.g., the Friday following Tuesday, January 15th, 2002</span>
<span class="c1">//   was January 18th, 2002.</span>
<span class="c1">// see also http://www.cpearson.com/excel/DateTimeWS.htm</span>
<span class="k">constexpr</span> <span class="n">Date</span> <span class="nf">next_weekday</span><span class="p">(</span><span class="n">Date</span> <span class="n">d</span><span class="p">,</span> <span class="n">Weekday</span> <span class="n">desired_weekday</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// n-th given weekday in the given month and year</span>
<span class="c1">// E.g., the 4th Thursday of March, 1998 was March 26th,</span>
<span class="c1">// 1998.</span>
<span class="n">YearMonthDay</span> <span class="nf">nth_weekday</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">wd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">year</span><span class="p">);</span>

<span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">is_weekend</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">wd</span><span class="p">);</span>

<span class="c1">// Min allowed date is Jan 1st 1901</span>
<span class="c1">// This is imposed by OpenRedukti</span>
<span class="c1">// This is helpful because then 0 can be used to represent an invalid date</span>
<span class="k">constexpr</span> <span class="n">Date</span> <span class="nf">minimum_date</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// We limit the max date so that we can ensure date values</span>
<span class="c1">// fit in 24 bits</span>
<span class="c1">// Dec 31st, 2199</span>
<span class="k">constexpr</span> <span class="n">Date</span> <span class="nf">maximum_date</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// Parse a string representation of date</span>
<span class="c1">// It will detect seperator character &#39;/&#39; or &#39;-&#39;.</span>
<span class="c1">// The formats acceptable are yyyy/mm/dd, dd/mm/yyyy, yyyy-mm-dd, or dd-mm-yyyy</span>
<span class="c1">// No exceptions thrown</span>
<span class="c1">// Returns true on success</span>
<span class="kt">bool</span> <span class="nf">parse_date</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">Date</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// We need to ensure that 0 is not a valid date as this</span>
<span class="c1">// helps us with protobuf representation of dates as integers</span>
<span class="c1">// where unspecified value is 0.</span>
<span class="c1">// Another requirement is to limit the max date so that</span>
<span class="c1">// date values can fit into 24 bits.</span>
<span class="kt">bool</span> <span class="nf">is_valid_date</span><span class="p">(</span><span class="n">Date</span> <span class="n">date</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="holiday-calendars">
<h2>Holiday Calendars<a class="headerlink" href="#holiday-calendars" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;calendars.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>OpenRedukti comes with predefined calendar implementations for following Business Centers:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">AUSY</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EUTA</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GBLO</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">USNY</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">JPTO</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BRSP</span></code></p></li>
</ul>
<p>These implementations are derived from the QuantLib library.
You can also override or create one of the defined calendar enums by suppling a list of holidays.</p>
<p>The Calendar API is as described below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// The Calendar interface provides the means to determine whether</span>
<span class="c1">// a given date is a holiday for a business center or not. Also</span>
<span class="c1">// the interface provides methods for adjusting dates as per the</span>
<span class="c1">// holiday calendar.</span>
<span class="c1">// Immutable for thread safety.</span>
<span class="k">class</span> <span class="nc">Calendar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">Calendar</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">id</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Returns all the ids - relevant for calendars made by combining</span>
   <span class="c1">// others</span>
   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">get_ids</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">BusinessCenter</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">ids</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">is_holiday</span><span class="p">(</span><span class="n">Date</span> <span class="n">d</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="nf">is_businessday</span><span class="p">(</span><span class="n">Date</span> <span class="n">d</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="nf">is_end_of_month</span><span class="p">(</span><span class="n">Date</span> <span class="n">d</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Adjust the given date to be the last business day of the month</span>
   <span class="n">Date</span> <span class="nf">end_of_month</span><span class="p">(</span><span class="n">Date</span> <span class="n">d</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Adjusts a non-business day to the appropriate near business day</span>
   <span class="c1">// with respect to the given convention.</span>
   <span class="n">Date</span> <span class="nf">adjust</span><span class="p">(</span><span class="n">Date</span> <span class="n">date</span><span class="p">,</span> <span class="n">BusinessDayConvention</span> <span class="n">convention</span> <span class="o">=</span> <span class="n">BusinessDayConvention</span><span class="o">::</span><span class="n">FOLLOWING</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Advances the given date of the given number of business days and</span>
   <span class="c1">// returns the result. Note that if unit is Days then business day</span>
   <span class="c1">// convention and eom flags are not used as the date is moved by the</span>
   <span class="c1">// specified business days. For other period units the date is moved as</span>
   <span class="c1">// per raw calendar and then adjusted if it falls on a holiday</span>
   <span class="n">Date</span> <span class="nf">advance</span><span class="p">(</span><span class="n">Date</span> <span class="n">date</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">PeriodUnit</span> <span class="n">unit</span><span class="p">,</span>
           <span class="n">BusinessDayConvention</span> <span class="n">convention</span> <span class="o">=</span> <span class="n">BusinessDayConvention</span><span class="o">::</span><span class="n">FOLLOWING</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">endOfMonth</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="k">const</span>
       <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Advances the given date as specified by the given period and</span>
   <span class="c1">// returns the result.</span>
   <span class="c1">// The input date is not modified.</span>
   <span class="n">Date</span> <span class="nf">advance</span><span class="p">(</span><span class="n">Date</span> <span class="n">date</span><span class="p">,</span> <span class="k">const</span> <span class="n">Period</span> <span class="o">&amp;</span><span class="n">period</span><span class="p">,</span>
           <span class="n">BusinessDayConvention</span> <span class="n">convention</span> <span class="o">=</span> <span class="n">BusinessDayConvention</span><span class="o">::</span><span class="n">FOLLOWING</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">endOfMonth</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="k">const</span>
       <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Calculates the number of business days between two given</span>
   <span class="c1">// dates and returns the result.</span>
   <span class="c1">//</span>
   <span class="kt">int</span> <span class="nf">business_days_between</span><span class="p">(</span><span class="n">Date</span> <span class="n">from</span><span class="p">,</span> <span class="n">Date</span> <span class="n">to</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">includeFirst</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">includeLast</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="k">const</span>
       <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">JointCalendarParameters</span> <span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">BusinessCenter</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">centers</span><span class="p">;</span>
   <span class="n">JointCalendarParameters</span><span class="p">(</span><span class="n">BusinessCenter</span> <span class="n">center1</span><span class="p">,</span> <span class="n">BusinessCenter</span> <span class="n">center2</span><span class="p">,</span>
            <span class="n">BusinessCenter</span> <span class="n">center3</span> <span class="o">=</span> <span class="n">BusinessCenter</span><span class="o">::</span><span class="n">BUSINESS_CENTER_UNSPECIFIED</span><span class="p">,</span>
            <span class="n">BusinessCenter</span> <span class="n">center4</span> <span class="o">=</span> <span class="n">BusinessCenter</span><span class="o">::</span><span class="n">BUSINESS_CENTER_UNSPECIFIED</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// The Calendar Service manages calendar instances. It has to meet following requirements:</span>
<span class="c1">// a) It must always return the same Calendar instance for a given business center. Clients</span>
<span class="c1">//    can assume that the instance will not go away or change in any way as long as the</span>
<span class="c1">//    service is live.</span>
<span class="c1">// b) Ditto for joint calendar instances.</span>
<span class="c1">// c) Calendar instances must be immutable.</span>
<span class="c1">// d) It must be threadsafe</span>
<span class="c1">//</span>
<span class="c1">// These requirements place some restrictions on when a calendar instance can be</span>
<span class="c1">// be defined. Essentially define calendar instances at system startup prior to any</span>
<span class="c1">// other operations with OpenRedukti</span>
<span class="k">class</span> <span class="nc">CalendarService</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">CalendarService</span><span class="p">()</span> <span class="p">{}</span>
   <span class="c1">// Return the calendar specified. Memory is managed by the</span>
   <span class="c1">// CalendarFactory so the caller must not delete.</span>
   <span class="k">virtual</span> <span class="k">const</span> <span class="n">Calendar</span> <span class="o">*</span><span class="n">get_calendar</span><span class="p">(</span><span class="n">BusinessCenter</span> <span class="n">id</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Set a calendar to given instance.</span>
   <span class="c1">// The service will take ownership of the instance</span>
   <span class="c1">// May fail if calendar instance already set and has been</span>
   <span class="c1">// accessed by a client - i.e. new calendars can only be set prior to</span>
   <span class="c1">// any use.</span>
   <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">set_calendar</span><span class="p">(</span><span class="n">BusinessCenter</span> <span class="n">id</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Calendar</span><span class="o">&gt;</span> <span class="n">calendar</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Create a calendar from a set of holidays and assign it to the business center</span>
   <span class="c1">// If the assignment is successful the service will take ownership of the instance</span>
   <span class="c1">// May fail if calendar instance already set and has been</span>
   <span class="c1">// accessed by a client - i.e. new calendars can only be set prior to</span>
   <span class="c1">// any use.</span>
   <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">set_calendar</span><span class="p">(</span><span class="n">BusinessCenter</span> <span class="n">id</span><span class="p">,</span> <span class="k">const</span> <span class="n">Date</span> <span class="o">*</span><span class="n">holidays</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

   <span class="c1">// Create joint calendar</span>
   <span class="c1">// Note that the order in which the business centers are given</span>
   <span class="c1">// should not matter - i.e. the constituents are sorted and then</span>
   <span class="c1">// combined so that for a given combination the returned instance is</span>
   <span class="c1">// always the same</span>
   <span class="k">virtual</span> <span class="n">Calendar</span> <span class="o">*</span><span class="nf">get_calendar</span><span class="p">(</span><span class="n">JointCalendarParameters</span> <span class="n">calendars</span><span class="p">,</span>
                   <span class="n">JointCalendarRule</span> <span class="n">rule</span> <span class="o">=</span> <span class="n">JointCalendarRule</span><span class="o">::</span><span class="n">JOIN_HOLIDAYS</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Front end to set_calendar()</span>
   <span class="k">virtual</span> <span class="n">RegisterCalendarReply</span> <span class="o">*</span><span class="nf">handle_register_calendar_request</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">RegisterCalendarRequest</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span> <span class="n">RegisterCalendarReply</span> <span class="o">*</span><span class="n">reply</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Gets the global calendar service</span>
<span class="c1">// As Calendars are immutable once constructed it is safe to allow</span>
<span class="c1">// them to be managed via a global Calendar Service</span>
<span class="k">extern</span> <span class="n">CalendarService</span> <span class="o">*</span><span class="nf">get_calendar_factory</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// Utility for constructing a joint calendar</span>
<span class="k">extern</span> <span class="k">const</span> <span class="n">Calendar</span> <span class="o">*</span><span class="nf">build_calendar</span><span class="p">(</span><span class="n">CalendarService</span> <span class="o">*</span><span class="n">calendar_service</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">RepeatedField</span><span class="o">&lt;</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">int32</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">values</span><span class="p">,</span>
                  <span class="n">JointCalendarRule</span> <span class="n">rule</span> <span class="o">=</span> <span class="n">JointCalendarRule</span><span class="o">::</span><span class="n">JOIN_HOLIDAYS</span><span class="p">);</span>

<span class="c1">// Utility for constructing a joint calendar</span>
<span class="k">const</span> <span class="n">Calendar</span> <span class="o">*</span><span class="nf">build_calendar</span><span class="p">(</span><span class="n">CalendarService</span> <span class="o">*</span><span class="n">calendar_service</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BusinessCenter</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">values</span><span class="p">,</span>
                <span class="n">JointCalendarRule</span> <span class="n">rule</span> <span class="o">=</span> <span class="n">JointCalendarRule</span><span class="o">::</span><span class="n">JOIN_HOLIDAYS</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="day-count-fractions">
<h2>Day Count Fractions<a class="headerlink" href="#day-count-fractions" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;dayfractions.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>OpenRedukti comes with support for following DayCountFraction implementations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">30/360</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">30E/360</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">30E/360.ISDA</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ACT/360</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ACT/365.FIXED</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ACT/ACT.ISDA</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ACT/ACT.ISMA</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BUS/252</span></code></p></li>
</ul>
<p>The implementation is derived from QuantLib.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Compute the difference between dates as per Day Count Convention.</span>
<span class="c1">// The difference is measured in factional units of a year, where one year 1.0.</span>
<span class="c1">// Must be immutable and thread-safe.</span>
<span class="c1">// Clients must be able to hold references to these for the lifetime of</span>
<span class="c1">// the application.</span>
<span class="k">class</span> <span class="nc">DayFraction</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">DayFraction</span><span class="p">()</span> <span class="p">{}</span>

   <span class="c1">// Calculate the difference d2-d2 as per convention</span>
   <span class="c1">// for the DayFraction; value is a decimal expressed as a year fraction.</span>
   <span class="c1">// So 1.0 means 1 year.</span>
   <span class="k">virtual</span> <span class="kt">double</span> <span class="n">year_fraction</span><span class="p">(</span><span class="n">Date</span> <span class="n">d1</span><span class="p">,</span> <span class="n">Date</span> <span class="n">d2</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

   <span class="c1">// Only used for ThirtyE360ISDA (30E/360.ISDA)</span>
   <span class="c1">// The finalPeriod flag indicates whether this fraction is for the</span>
   <span class="c1">// final period - i.e. d2 is maturity date. So typically,</span>
   <span class="c1">// when calculating the last calc period in a swap, this flag must be</span>
   <span class="c1">// set to true.</span>
   <span class="k">virtual</span> <span class="kt">double</span> <span class="nf">year_fraction</span><span class="p">(</span><span class="n">Date</span> <span class="n">d1</span><span class="p">,</span> <span class="n">Date</span> <span class="n">d2</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">finalPeriod</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

   <span class="c1">// Used only for ACT/ACT.ISMA</span>
   <span class="c1">// refStart - If regular period or front stub then adjusted end date</span>
   <span class="c1">//    minus calculation period frequency (roll convention NONE),</span>
   <span class="c1">//    else adjusted start date</span>
   <span class="c1">// refEnd - If regular period or front stub then adjusted end date,</span>
   <span class="c1">//    else adjusted start date minus calculation period</span>
   <span class="c1">//    frequency (roll convention NONE)</span>
   <span class="k">virtual</span> <span class="kt">double</span> <span class="nf">year_fraction</span><span class="p">(</span><span class="n">Date</span> <span class="n">d1</span><span class="p">,</span> <span class="n">Date</span> <span class="n">d2</span><span class="p">,</span> <span class="n">Date</span> <span class="n">refStart</span><span class="p">,</span> <span class="n">Date</span> <span class="n">refEnd</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

   <span class="c1">// Returns the ISDA name</span>
   <span class="k">virtual</span> <span class="n">DayCountFraction</span> <span class="nf">id</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Get an instance of a DayFraction</span>
<span class="c1">// Requirements:</span>
<span class="c1">// a) There must only be one instance associated with a particular DayCountFraction</span>
<span class="c1">// b) The DayCountFraction implementation must be immutable and hence thread-safe</span>
<span class="k">extern</span> <span class="k">const</span> <span class="n">DayFraction</span> <span class="o">*</span><span class="nf">get_day_fraction</span><span class="p">(</span><span class="n">DayCountFraction</span> <span class="n">dfc</span><span class="p">);</span>

<span class="c1">// The BUS252 day fraction requires a calendar.</span>
<span class="c1">// Requirements:</span>
<span class="c1">// a) There must only be one instance associated with a particular DayCountFraction</span>
<span class="c1">// b) The DayCountFraction implementation must be immutable and hence thread-safe</span>
<span class="k">extern</span> <span class="k">const</span> <span class="n">DayFraction</span> <span class="o">*</span><span class="nf">get_bus_252</span><span class="p">(</span><span class="n">CalendarService</span> <span class="o">*</span><span class="n">calendarService</span><span class="p">,</span> <span class="n">BusinessCenter</span> <span class="n">center</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="index-types">
<h2>Index Types<a class="headerlink" href="#index-types" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;index.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">IndexDefinition</span></code> type captures essential information for working with indices.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Captures information about an interest rate</span>
<span class="c1">// index so that various operations associated with the</span>
<span class="c1">// index can be performed.</span>
<span class="n">message</span> <span class="n">IndexDefinition</span> <span class="p">{</span>
   <span class="c1">// This is the FpML / ISDA name of the index</span>
   <span class="c1">// Excludes tenor</span>
   <span class="n">IsdaIndex</span> <span class="n">isda_index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="c1">// Index family may be common across several indices</span>
   <span class="n">IndexFamily</span> <span class="n">index_family</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="c1">// Currency of the index</span>
   <span class="n">Currency</span> <span class="n">currency</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="c1">// Tenor of the index</span>
   <span class="c1">// May be left unspecified to use as the default configuration</span>
   <span class="c1">// for all tenors for the index family</span>
   <span class="n">Tenor</span> <span class="n">tenor</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
   <span class="c1">// Number of business days between a value date and fixing date</span>
   <span class="n">int32</span> <span class="n">fixing_lag</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
   <span class="c1">// Used to select the business day convention</span>
   <span class="c1">// tenors &lt;= short_tenor_threshold use the short tenor convention</span>
   <span class="n">Tenor</span> <span class="n">short_tenor_threshold</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
   <span class="c1">// Convention used if tenor is &lt;= short_tenor_threshold</span>
   <span class="n">BusinessDayConvention</span> <span class="n">short_tenor_convention</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
   <span class="c1">// Convention used if tenor is &gt; than short_tenor_threshold</span>
   <span class="n">BusinessDayConvention</span> <span class="n">long_tenor_convention</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
   <span class="c1">// Whether to apply EOM roll convention for tenors &gt;= month</span>
   <span class="kt">bool</span> <span class="n">eom</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
   <span class="c1">// fixing calendars are used to move from accrual start date</span>
   <span class="c1">// to fixing date, and also to move from fixing date to</span>
   <span class="c1">// value date</span>
   <span class="n">repeated</span> <span class="n">BusinessCenter</span> <span class="n">fixing_calendars</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
   <span class="c1">// How to combine fixing calendars</span>
   <span class="n">JointCalendarRule</span> <span class="n">fixing_calendars_join_rule</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
   <span class="c1">// The value date is checked against the value date</span>
   <span class="c1">// calendars and if it falls on a holiday then</span>
   <span class="c1">// an adjustment is applied using business day convention</span>
   <span class="n">repeated</span> <span class="n">BusinessCenter</span> <span class="n">value_date_calendars</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
   <span class="c1">// How value date calendars are to be combined</span>
   <span class="n">JointCalendarRule</span> <span class="n">value_date_calendars_join_rule</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
   <span class="c1">// The index calendars are used to calculate the maturity date</span>
   <span class="n">repeated</span> <span class="n">BusinessCenter</span> <span class="n">index_calendars</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
   <span class="c1">// How index date calendars are to be combined</span>
   <span class="n">JointCalendarRule</span> <span class="n">index_calendars_join_rule</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
   <span class="c1">// The day count fraction associated with the index</span>
   <span class="n">DayCountFraction</span> <span class="n">day_count_fraction</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
   <span class="c1">// Is this Isda Index default for the currency and index family?</span>
   <span class="kt">bool</span> <span class="n">default_for_index_family</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here is an example of how this is defined in C++ code for <code class="docutils literal notranslate"><span class="pre">USD</span> <span class="pre">LIBOR</span> <span class="pre">1D</span></code> index:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">IndexDefinition</span> <span class="n">definition</span><span class="p">;</span>
<span class="n">definition</span><span class="p">.</span><span class="n">set_isda_index</span><span class="p">(</span><span class="n">IsdaIndex</span><span class="o">::</span><span class="n">USD_LIBOR_BBA</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">set_index_family</span><span class="p">(</span><span class="n">IndexFamily</span><span class="o">::</span><span class="n">LIBOR</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">set_currency</span><span class="p">(</span><span class="n">Currency</span><span class="o">::</span><span class="n">USD</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">set_tenor</span><span class="p">(</span><span class="n">TENOR_1D</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">set_fixing_lag</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">set_short_tenor_threshold</span><span class="p">(</span><span class="n">TENOR_2W</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">set_short_tenor_convention</span><span class="p">(</span><span class="n">BusinessDayConvention</span><span class="o">::</span><span class="n">FOLLOWING</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">set_long_tenor_convention</span><span class="p">(</span><span class="n">BusinessDayConvention</span><span class="o">::</span><span class="n">MODIFIED_FOLLOWING</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">add_fixing_calendars</span><span class="p">(</span><span class="n">GBLO</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">set_fixing_calendars_join_rule</span><span class="p">(</span><span class="n">JOIN_HOLIDAYS</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">add_value_date_calendars</span><span class="p">(</span><span class="n">GBLO</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">add_value_date_calendars</span><span class="p">(</span><span class="n">USNY</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">set_value_date_calendars_join_rule</span><span class="p">(</span><span class="n">JOIN_HOLIDAYS</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">add_index_calendars</span><span class="p">(</span><span class="n">GBLO</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">add_index_calendars</span><span class="p">(</span><span class="n">USNY</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">set_index_calendars_join_rule</span><span class="p">(</span><span class="n">JOIN_HOLIDAYS</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">set_day_count_fraction</span><span class="p">(</span><span class="n">DayCountFraction</span><span class="o">::</span><span class="n">ACT_360</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">set_default_for_index_family</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">set_eom</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>To support other tenors, one can simply take above and change folloowing:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">definition</span><span class="p">.</span><span class="n">set_tenor</span><span class="p">(</span><span class="n">TENOR_UNSPECIFIED</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">set_fixing_lag</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">definition</span><span class="p">.</span><span class="n">set_eom</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">IndexDefinition</span></code> acts as a template for creating instances of the <code class="docutils literal notranslate"><span class="pre">InterestRateIndex</span></code> type.</p>
<p>The C++ API for working with indices is given below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Unique identifier for an index</span>
<span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">IndexId</span><span class="p">;</span>

<span class="c1">// Makes a unique identifier from the give ISDA index identifier and</span>
<span class="c1">// tenor</span>
<span class="n">IndexId</span> <span class="nf">make_index_id</span><span class="p">(</span><span class="n">IsdaIndex</span> <span class="n">isda_index</span><span class="p">,</span> <span class="n">Tenor</span> <span class="n">tenor</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">IndexDefinition</span><span class="p">;</span>

<span class="c1">// Base type for all indices</span>
<span class="k">class</span> <span class="nc">Index</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">Index</span><span class="p">()</span> <span class="p">{}</span>
   <span class="k">virtual</span> <span class="n">IndexId</span> <span class="n">id</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// An interest rate index representation. A requirement of</span>
<span class="c1">// OpenRedukti is that an each unique IndexId should map to one</span>
<span class="c1">// InterestRateIndex instance - as this allows the code to freely</span>
<span class="c1">// reference such instances without fear of the reference going away.</span>
<span class="c1">// Additionally a requirement is that the instance is immutable.</span>
<span class="k">class</span> <span class="nc">InterestRateIndex</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Index</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">InterestRateIndex</span><span class="p">();</span>
   <span class="k">virtual</span> <span class="n">Currency</span> <span class="nf">currency</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">IndexFamily</span> <span class="nf">family</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">Tenor</span> <span class="nf">tenor</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">IsdaIndex</span> <span class="nf">isda_index</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="c1">// Given a fixing date, calculate the value date</span>
   <span class="c1">// by applying the calendars, day conventions associated</span>
   <span class="c1">// with the index</span>
   <span class="k">virtual</span> <span class="n">Date</span> <span class="nf">value_date</span><span class="p">(</span><span class="n">Date</span> <span class="n">fixing_date</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

   <span class="c1">// Given a value date, calculate the fixing date</span>
   <span class="c1">// by applying the calendars, day conventions associated</span>
   <span class="c1">// with the index</span>
   <span class="k">virtual</span> <span class="n">Date</span> <span class="nf">fixing_date</span><span class="p">(</span><span class="n">Date</span> <span class="n">accrual_start_date</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

   <span class="c1">// Given a value date calculate the maturity date</span>
   <span class="c1">// Appropriate calendars, day conventions and EOM rules</span>
   <span class="c1">// must be applied</span>
   <span class="k">virtual</span> <span class="n">Date</span> <span class="nf">maturity_date</span><span class="p">(</span><span class="n">Date</span> <span class="n">value_date</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">is_valid_fixing_date</span><span class="p">(</span><span class="n">Date</span> <span class="n">date</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="k">const</span> <span class="n">Calendar</span> <span class="o">*</span><span class="nf">fixing_calendar</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="k">const</span> <span class="n">DayFraction</span> <span class="o">*</span><span class="nf">day_fraction</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">BusinessDayConvention</span> <span class="nf">day_convention</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// The IndexService is responsible for returning instances of InterestRateIndex.</span>
<span class="c1">// Note that the index service must ensure the following:</span>
<span class="c1">// a) There will only ever be one instance of an InterestRateIndex for a given</span>
<span class="c1">//    IndexId.</span>
<span class="c1">// b) Clients must be free to hold on to references to such instances without</span>
<span class="c1">//    fear of them going out of scope. So essentially these instances can only be</span>
<span class="c1">//    deleted at system shutdown.</span>
<span class="c1">// c) An InterestRateIndex instance must be immutable.</span>
<span class="k">class</span> <span class="nc">IndexService</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">IndexService</span><span class="p">()</span> <span class="p">{}</span>

   <span class="c1">// Adds a definition for use as a template for generating instances of</span>
   <span class="c1">// InterestRateIndex</span>
   <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">register_index</span><span class="p">(</span><span class="k">const</span> <span class="n">IndexDefinition</span> <span class="o">&amp;</span><span class="n">definition</span><span class="p">);</span>

   <span class="c1">// Obtains an instance of IntrestRateIndex - must return an existing instance</span>
   <span class="c1">// if already defined</span>
   <span class="k">virtual</span> <span class="n">InterestRateIndex</span> <span class="o">*</span><span class="nf">get_index</span><span class="p">(</span><span class="n">IsdaIndex</span> <span class="n">isda_index</span><span class="p">,</span> <span class="n">Tenor</span> <span class="n">tenor</span><span class="p">);</span>

   <span class="c1">// Obtains an instance of IntrestRateIndex - must return an existing instance</span>
   <span class="c1">// if already defined</span>
   <span class="k">virtual</span> <span class="n">InterestRateIndex</span> <span class="o">*</span><span class="nf">get_index</span><span class="p">(</span><span class="n">Currency</span> <span class="n">currency</span><span class="p">,</span> <span class="n">IndexFamily</span> <span class="n">index_family</span><span class="p">,</span> <span class="n">Tenor</span> <span class="n">tenor</span><span class="p">);</span>

   <span class="c1">// front-end to register_index()</span>
   <span class="k">virtual</span> <span class="n">RegisterIndexDefinitionReply</span> <span class="o">*</span>
      <span class="nf">handle_register_index_definition_request</span><span class="p">(</span><span class="k">const</span> <span class="n">RegisterIndexDefinitionRequest</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span>
             <span class="n">RegisterIndexDefinitionReply</span> <span class="o">*</span><span class="n">reply</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="n">IndexService</span> <span class="o">*</span><span class="nf">get_default_index_service</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="useful-conversions">
<h2>Useful Conversions<a class="headerlink" href="#useful-conversions" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;converters.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>The API is as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Converter</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">Converter</span><span class="p">()</span> <span class="p">{}</span>
   <span class="k">virtual</span> <span class="n">BusinessCenter</span> <span class="n">business_center_from_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">BusinessDayConvention</span> <span class="nf">business_day_convention_from_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">PeriodUnit</span> <span class="nf">period_unit_from_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">period_from_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">periodName</span><span class="p">,</span> <span class="n">Period</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">DayCountFraction</span> <span class="nf">day_count_fraction_from_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">Tenor</span> <span class="nf">tenor_from_period_unit_and_len</span><span class="p">(</span><span class="n">PeriodUnit</span> <span class="n">unit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">tenor_to_period_unit_and_multiplier</span><span class="p">(</span><span class="n">Tenor</span> <span class="n">value</span><span class="p">,</span> <span class="n">PeriodUnit</span> <span class="o">*</span><span class="n">unit</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">mult</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">tenor_to_string</span><span class="p">(</span><span class="n">Tenor</span> <span class="n">tenor</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">RollConvention</span> <span class="nf">roll_convention_from_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">Currency</span> <span class="nf">currency_from_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">currency_to_string</span><span class="p">(</span><span class="n">Currency</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">IsdaIndex</span> <span class="nf">isda_index_from_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">isda_index_to_string</span><span class="p">(</span><span class="n">IsdaIndex</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">CompoundingMethod</span> <span class="nf">compounding_method_from_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">IndexFamily</span> <span class="nf">index_family_from_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">index_family_to_string</span><span class="p">(</span><span class="n">IndexFamily</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">period_unit_to_string</span><span class="p">(</span><span class="n">PeriodUnit</span> <span class="n">period_unit</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">tenor_to_days</span><span class="p">(</span><span class="n">Tenor</span> <span class="n">tenor</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">InterpolatorType</span> <span class="nf">interpolator_type_from_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">PricingCurveType</span> <span class="nf">pricing_curve_type_from_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">IRRateType</span> <span class="nf">rate_type_from_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">CurveGroup</span> <span class="nf">curve_group_from_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">MaturityGenerationRule</span> <span class="nf">maturity_generation_rule_from_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">const</span> <span class="n">Converter</span> <span class="o">*</span><span class="nf">get_default_converter</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="automatic-differentiation">
<h2>Automatic Differentiation<a class="headerlink" href="#automatic-differentiation" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;autodiff.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>OpenRedukti makes use of automatic differentiation techniques to compute derivatives. This approach enables
computation of derivatives more accurately than would be possible using numeric differentation. On the other
hand, it is possible to implement fairly complex derivatives without having to construct the derivatives by
hand.</p>
<p>This approach does have the drawback that it is compute and memory intensive. Hence to improve performance
special care is taken with regards to memory management.</p>
<p>The implementation of the adouble type is based on followinG
* <a class="reference external" href="https://github.com/redukti/OpenRedukti/blob/master/docs/Sensitivities.pdf">Calculating Sensitivities</a>.
* <a class="reference external" href="http://adl.stanford.edu/hyperdual/">vector-mode hyper-dual numbers</a> by Jeffrey A. Fike at Stanford University, Department of Aeronautics and Astronautics.</p>
<p>Note that this API is pretty low level and requires the caller to be aware of and manage memory explicitly. This is deliberate as the cost of memory management can overwhelm performance of this API.</p>
<p>The core API is as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// WARNING</span>
<span class="c1">//</span>
<span class="c1">// This is a low level module that must be used with care.</span>
<span class="c1">// In general this module requires the caller to allocate memory</span>
<span class="c1">// correctly - as it assumes that all supplied arguments are</span>
<span class="c1">// properly sized and allocated.</span>

<span class="cm">/* autodiff variable */</span>
<span class="k">struct</span> <span class="n">redukti_adouble_t</span> <span class="p">{</span>
   <span class="c1">// derivative order</span>
   <span class="kt">uint32_t</span> <span class="nl">order_</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>
   <span class="c1">// number of variables</span>
   <span class="kt">uint32_t</span> <span class="n">vars_</span><span class="p">;</span>
   <span class="c1">// data</span>
   <span class="kt">double</span> <span class="n">data_</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

   <span class="n">redukti_adouble_t</span><span class="p">(</span><span class="k">const</span> <span class="n">redukti_adouble_t</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">redukti_adouble_t</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">redukti_adouble_t</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Compute memory requirement for given number of variables and order</span>
<span class="c1">// Supported orders are 0,1,2.</span>
<span class="kt">size_t</span> <span class="nf">redukti_adouble_alloc_size</span><span class="p">(</span><span class="kt">int</span> <span class="n">vars</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">);</span>

<span class="c1">// Initialize A; caller must have allocated memory of correct</span>
<span class="c1">// size.</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_init</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_vars</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="kt">double</span> <span class="n">v</span><span class="p">);</span>

<span class="c1">// A = B</span>
<span class="c1">// must be same size</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_assign</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="k">const</span> <span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">B</span><span class="p">);</span>

<span class="c1">// A = A + alpha*B</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_add</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">B</span><span class="p">,</span> <span class="kt">double</span> <span class="n">alpha</span><span class="p">);</span>

<span class="c1">// A = A*scalar</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_scalar_multiply</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="kt">double</span> <span class="n">alpha</span><span class="p">);</span>

<span class="c1">// A = A*B</span>
<span class="c1">// A = A*A also works</span>
<span class="c1">// temp must be same size as A</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_multiply</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">B</span><span class="p">,</span> <span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">temp</span><span class="p">);</span>

<span class="c1">// A = A/B</span>
<span class="c1">// temp1, temp2 must be same size as A</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_divide</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">B</span><span class="p">,</span> <span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">temp1</span><span class="p">,</span>
             <span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">temp2</span><span class="p">);</span>

<span class="c1">// A = exp(A)</span>
<span class="c1">// temp must be same size as A</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_exp</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">temp</span><span class="p">);</span>

<span class="c1">// A = log(A)</span>
<span class="c1">// temp must be same size as A</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_log</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">temp</span><span class="p">);</span>

<span class="c1">// A = A^p</span>
<span class="c1">// temp must be same size as A</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_power</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">temp</span><span class="p">);</span>

<span class="c1">// A = abs(A)</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_abs</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">);</span>

<span class="c1">// A = sin(A)</span>
<span class="c1">// temp must be same size as A</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_sin</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">temp</span><span class="p">);</span>

<span class="c1">// A = cos(A)</span>
<span class="c1">// temp must be same size as A</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_cos</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">temp</span><span class="p">);</span>

<span class="c1">// A = tan(A)</span>
<span class="c1">// temp must be same size as A</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_tan</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">temp</span><span class="p">);</span>

<span class="c1">// Dumps contents of A</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_dump</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>

<span class="c1">// A = A + alpha</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_scalar_add</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="kt">double</span> <span class="n">alpha</span><span class="p">);</span>

<span class="c1">// Get A&#39;s value</span>
<span class="kt">double</span> <span class="nf">redukti_adouble_get_value</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">);</span>

<span class="c1">// Get first derivative with respect to variable</span>
<span class="kt">double</span> <span class="nf">redukti_adouble_get_derivative1</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parameter</span><span class="p">);</span>

<span class="c1">// Get second derivative with respect to variables</span>
<span class="kt">double</span> <span class="nf">redukti_adouble_get_derivative2</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parameter1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parameter2</span><span class="p">);</span>

<span class="c1">// Set A&#39;s value</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_set_value</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="kt">double</span> <span class="n">v</span><span class="p">);</span>

<span class="c1">// Set first derivative with respect to variable</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_set_derivative1</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parameter</span><span class="p">,</span> <span class="kt">double</span> <span class="n">v</span><span class="p">);</span>

<span class="c1">// Set second derivative with respect to variables</span>
<span class="kt">void</span> <span class="nf">redukti_adouble_set_derivative2</span><span class="p">(</span><span class="n">redukti_adouble_t</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parameter1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parameter2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">v</span><span class="p">);</span>
</pre></div>
</div>
<p>It is best to try to use the scriting API to get an understanding of how automatic differentiation works.</p>
</div>
<div class="section" id="calculation-schedules">
<h2>Calculation Schedules<a class="headerlink" href="#calculation-schedules" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;schedule.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>The following protocol buffer definitions capture parameters for creating calculation scheduled:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">StubLocation</span> <span class="p">{</span>
   <span class="n">STUB_TYPE_AUTO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">SHORT_FRONT_STUB</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">LONG_FRONT_STUB</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="n">SHORT_BACK_STUB</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="n">LONG_BACK_STUB</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">ScheduleParameters</span> <span class="p">{</span>
   <span class="n">int32</span> <span class="n">effective_date</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">termination_date</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="n">RollConvention</span> <span class="n">roll_convention</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">first_regular_period_start_date</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">last_regular_period_end_date</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
   <span class="n">Tenor</span> <span class="n">term</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
   <span class="n">Tenor</span> <span class="n">calculation_frequency</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
   <span class="n">Tenor</span> <span class="n">payment_frequency</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
   <span class="n">StubLocation</span> <span class="n">stub_location</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">first_payment_date</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">last_regular_payment_date</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
   <span class="n">BusinessDayConvention</span> <span class="n">period_convention</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
   <span class="n">BusinessDayConvention</span> <span class="n">payment_convention</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
   <span class="n">sint32</span> <span class="n">payment_lag</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
   <span class="n">repeated</span> <span class="n">BusinessCenter</span> <span class="n">period_calendars</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
   <span class="n">repeated</span> <span class="n">BusinessCenter</span> <span class="n">payment_calendars</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">Schedule</span> <span class="p">{</span>
   <span class="kt">bool</span> <span class="n">has_front_stub</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="n">has_back_stub</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="n">repeated</span> <span class="n">int32</span> <span class="n">adjusted_start_dates</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="n">repeated</span> <span class="n">int32</span> <span class="n">adjusted_end_dates</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
   <span class="c1">// payment date may be zero if not applicable for a period</span>
   <span class="n">repeated</span> <span class="n">int32</span> <span class="n">adjusted_payment_dates</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The C++ API to generate a schedule from given parameters is as defined below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ScheduleParameters</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Schedule</span><span class="p">;</span>

<span class="c1">// Build a schedule as per the schedule parameters</span>
<span class="c1">// If succesful returns true</span>
<span class="k">extern</span> <span class="kt">bool</span> <span class="nf">build_schedule</span><span class="p">(</span><span class="n">ScheduleParameters</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">Schedule</span> <span class="o">&amp;</span><span class="n">schedule</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// Adjusts a date as per roll convention specified</span>
<span class="k">extern</span> <span class="n">Date</span> <span class="nf">adjust_date</span><span class="p">(</span><span class="n">Date</span> <span class="n">d</span><span class="p">,</span> <span class="n">RollConvention</span> <span class="n">rc</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="memory-allocators">
<h2>Memory Allocators<a class="headerlink" href="#memory-allocators" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;allocators.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>OpenRedukti uses a bunch of allocators that aim to reduce the overhead in allocating and releasing memory.
The general interface implemented by all the allocators are:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// IMPORTANT</span>
<span class="c1">//</span>
<span class="c1">// The allocators defined below are NOT thread safe</span>
<span class="c1">// You must ensure that an allocator (other than the</span>
<span class="c1">// MallocAllocator to be accurate) is never shared across</span>
<span class="c1">// threads</span>
<span class="c1">//</span>
<span class="c1">// Secondly these allocators are fine tuned to requirements</span>
<span class="c1">// in this project and are not general purpose.</span>

<span class="c1">// Generic allocator interface</span>
<span class="k">class</span> <span class="nc">Allocator</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">Allocator</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Allocate at least size bytes</span>
   <span class="c1">// A size of 0 will result in nullptr being returned</span>
   <span class="k">virtual</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">allocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">void</span> <span class="o">*</span><span class="nf">safe_allocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Depending upon the type of allocator a deallocate may</span>
   <span class="c1">// not do anything</span>
   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">deallocate</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">address</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>When objects are allocated and then captured in std::unique_ptr, it is necessary to provide a deleter object to
correctly deallocate memory. For this, the following is provided:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Utility for associating a deleter with a</span>
<span class="c1">// unique_ptr when memory was allocated using an allocator.</span>
<span class="c1">//</span>
<span class="c1">// Example:</span>
<span class="c1">//  Allocator *A;</span>
<span class="c1">//  std::unique_ptr&lt;YieldCurve, Deleter&lt;YieldCurve&gt;&gt;(</span>
<span class="c1">// new (*A) YieldCurve(), Deleter&lt;YieldCurve&gt;(A));</span>
<span class="c1">//</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Deleter</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">Deleter</span><span class="p">(</span><span class="n">Allocator</span> <span class="o">*</span><span class="n">A</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="o">:</span> <span class="n">A_</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
   <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">T</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>An extension of the Allocator interface provides allocation strategies where all memory is released at once rather than
object at a time.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Allocator interface where it is not necessary</span>
<span class="c1">// to destroy or free individual objects</span>
<span class="c1">//</span>
<span class="c1">// IMPORTANT</span>
<span class="c1">//</span>
<span class="c1">// Do not use for objects requiring destruction</span>
<span class="c1">//</span>
<span class="k">class</span> <span class="nc">RegionAllocator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Allocator</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="c1">// When a RegionAllocator is destroyed all memory allocated</span>
   <span class="c1">// may be released depending upon how the allocator</span>
   <span class="c1">// acquired that memory. User does not need to call</span>
   <span class="c1">// deallocate() explicitly on objects.</span>
   <span class="c1">// Note therefore that this allocator is unsuitable for</span>
   <span class="c1">// objects with destructors!</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">RegionAllocator</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">virtual</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">allocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Deallocate does nothing</span>
   <span class="kt">void</span> <span class="nf">deallocate</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">address</span><span class="p">)</span> <span class="k">noexcept</span> <span class="k">override</span> <span class="k">final</span> <span class="p">{}</span>

   <span class="c1">// Resets the allocator so that all memory</span>
   <span class="c1">// is either freed and available for reuse</span>
   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">release</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We have a FixedRegionAllocator that allocates from a predefined memory buffer.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// This is an allocator that returns memory from a fixed</span>
<span class="c1">// sized memory buffer. The buffer may be externally provided or</span>
<span class="c1">// owned. When the buffer is exhausted any allocation requests</span>
<span class="c1">// will fail and allocate() will return nullptr.</span>
<span class="c1">//</span>
<span class="c1">// As it is a RegionAllocator, deallocate() is a no-op</span>
<span class="k">struct</span> <span class="nl">FixedRegionAllocator</span> <span class="p">:</span> <span class="k">public</span> <span class="n">RegionAllocator</span> <span class="p">{</span>

   <span class="c1">// memory externally supplied</span>
   <span class="n">FixedRegionAllocator</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// memory externally supplied</span>
   <span class="n">FixedRegionAllocator</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Acquire memory</span>
   <span class="c1">// Memory will be owned by this instance</span>
   <span class="n">FixedRegionAllocator</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Current position</span>
   <span class="kt">size_t</span> <span class="nf">pos</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Sets current position</span>
   <span class="c1">// This is useful for scenarios where the user</span>
   <span class="c1">// wants to use the allocator in a stack like fashion</span>
   <span class="c1">// This is used by FixedRegionAllocatorGuard to</span>
   <span class="c1">// undo allocation upon destruction</span>
   <span class="kt">void</span> <span class="nf">pos</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">};</span>
</pre></div>
</div>
<p>Since often memory can be allocated and deallocated in a stack like fashion, a FixedRegionAllocator can be used in
combination with a guard to save/restore the allocation state, effectively releasing memory when the guard destructs.
For this we have:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// This guard can be used to restore a FixedRegionAllocator to</span>
<span class="c1">// its previous allocation state. It relies on the fact that</span>
<span class="c1">// a FixedRegionAllocator is a bump the pointer allocator, and</span>
<span class="c1">// can be restored by simply reseting the pointer to the previous</span>
<span class="c1">// position</span>
<span class="k">class</span> <span class="nc">FixedRegionAllocatorGuard</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">FixedRegionAllocatorGuard</span><span class="p">(</span><span class="n">FixedRegionAllocator</span> <span class="o">*</span><span class="n">A</span><span class="p">);</span>
   <span class="o">~</span><span class="n">FixedRegionAllocatorGuard</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>For scenarios where OpenRedukti is being used as a server, it is often the case that each request is served by a thread,
and while the thread executes it needs to allocate temporary memory for performing calculations. To faclitate this usage,
OpenRedukti provides some predefined thread specific allocators.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Each thread is given a set of allocators to use</span>
<span class="c1">// To obtain the thread specific allocator set call</span>
<span class="c1">// get_threadspecific_allocators().</span>
<span class="k">struct</span> <span class="n">AllocatorSet</span> <span class="p">{</span>
   <span class="n">RegionAllocator</span> <span class="o">*</span><span class="n">cashflow_allocator</span><span class="p">;</span>
   <span class="n">RegionAllocator</span> <span class="o">*</span><span class="n">sensitivities_allocator</span><span class="p">;</span>
   <span class="n">FixedRegionAllocator</span> <span class="o">*</span><span class="n">tempspace_allocator</span><span class="p">;</span>

   <span class="c1">// Resets all the allocators</span>
   <span class="c1">// Use this after the thread has finished serving so that</span>
   <span class="c1">// the allocators are properly initialized for the next request</span>
   <span class="kt">void</span> <span class="nf">reset</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// Retrieves the thread specific allocator set.</span>
<span class="k">extern</span> <span class="n">AllocatorSet</span> <span class="o">*</span><span class="nf">get_threadspecific_allocators</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="interpolators">
<h2>Interpolators<a class="headerlink" href="#interpolators" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;interpolators.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>OpenRedukti supports the most common interpolators used in interest rate curves. The API for setting up interpolators is
described below.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">InterpolationOptions</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Interpolator</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">Interpolator</span><span class="p">()</span> <span class="p">{}</span>

   <span class="c1">// Interpolate at x</span>
   <span class="k">virtual</span> <span class="kt">double</span> <span class="n">interpolate</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>

   <span class="c1">// Interpolate at x</span>
   <span class="c1">// And also compute sensitivities of value at x</span>
   <span class="c1">// to the various terms in the data set.</span>
   <span class="c1">// Both first order and second order sensitivies</span>
   <span class="c1">// can be computed depending upon how the</span>
   <span class="c1">// the interpolator was created.</span>
   <span class="c1">// Uses automatic differentiation</span>
   <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">redukti_adouble_t</span><span class="p">,</span> <span class="n">Deleter</span><span class="o">&lt;</span><span class="n">redukti_adouble_t</span><span class="o">&gt;&gt;</span>
   <span class="n">interpolate_with_sensitivities</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">FixedRegionAllocator</span> <span class="o">*</span><span class="n">A</span><span class="p">);</span>

   <span class="c1">// Interpolate at x</span>
   <span class="c1">// And also compute sensitivities of value at x</span>
   <span class="c1">// to the various terms in the data set.</span>
   <span class="c1">// Both first order and second order sensitivies</span>
   <span class="c1">// can be computed depending upon how the</span>
   <span class="c1">// the interpolator was created.</span>
   <span class="c1">// Uses numeric differentiation</span>
   <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">redukti_adouble_t</span><span class="p">,</span> <span class="n">Deleter</span><span class="o">&lt;</span><span class="n">redukti_adouble_t</span><span class="o">&gt;&gt;</span>
   <span class="n">interpolate_with_numeric_sensitivities</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">FixedRegionAllocator</span> <span class="o">*</span><span class="n">A</span><span class="p">);</span>

   <span class="c1">// If underlying values have changed, this</span>
   <span class="c1">// method can be called to reinitialise the</span>
   <span class="c1">// interpolator.</span>
   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">();</span>

   <span class="c1">// Only available on Monotone Convex interpolator as it is an</span>
   <span class="c1">// interest rate aware interpolator - for everything else</span>
   <span class="c1">// an exception will be thrown.</span>
   <span class="k">virtual</span> <span class="kt">double</span> <span class="nf">forward</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>

   <span class="c1">// Return the interpolator type</span>
   <span class="k">virtual</span> <span class="n">InterpolatorType</span> <span class="nf">type</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="c1">// Returns 0 if derivatives are not enabled</span>
   <span class="c1">// Returns 1 if first order derivatives are enabled</span>
   <span class="c1">// Returns 2 if both first and second order derivatives are enabled</span>
   <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">order</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="c1">// Returns the options that are enabled</span>
   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">get_options</span><span class="p">(</span><span class="n">InterpolationOptions</span> <span class="o">&amp;</span><span class="n">optons</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">InterpolationOptions</span> <span class="p">{</span>
   <span class="kt">bool</span> <span class="n">monotoneconvex_inputs_are_forwards</span><span class="p">;</span>
   <span class="kt">double</span> <span class="n">cubic_left_condition_value</span><span class="p">;</span>
   <span class="kt">double</span> <span class="n">cubic_right_condition_value</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="n">extrapolate</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">differentiation_order</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Return an Interpolator of the desired type.</span>
<span class="c1">// The x and y arrays will be referenced by the Interpolator,</span>
<span class="c1">// and therefore the caller must carefully manage</span>
<span class="c1">// changes.</span>
<span class="k">extern</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Interpolator</span><span class="p">,</span> <span class="n">Deleter</span><span class="o">&lt;</span><span class="n">Interpolator</span><span class="o">&gt;&gt;</span>
<span class="n">make_interpolator</span><span class="p">(</span><span class="n">InterpolatorType</span> <span class="n">type</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">Allocator</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">InterpolationOptions</span> <span class="o">&amp;</span><span class="n">options</span> <span class="o">=</span> <span class="n">InterpolationOptions</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="interest-rate-curves">
<h2>Interest Rate Curves<a class="headerlink" href="#interest-rate-curves" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;curve.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>OpenRedukti supports Zero Curves that are continuously compounded. Alternate representation using discount factors
is also supported.</p>
<p>There are a bunch of protocol buffers types related to curves.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Curve configuration instance</span>
<span class="c1">// For efficiency it is better to maintain</span>
<span class="c1">// this separately from actual curve data</span>
<span class="c1">// The definitions are static i.e. they do not change</span>
<span class="c1">// from day to day</span>
<span class="n">message</span> <span class="n">IRCurveDefinition</span> <span class="p">{</span>

   <span class="c1">// All curve definitions must be given a unique id</span>
   <span class="c1">// This can be considered to be some sort of primary key</span>
   <span class="c1">// for the definition - i.e. no two curve definitions may</span>
   <span class="c1">// have the same id</span>
   <span class="n">int32</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

   <span class="c1">// Curves may be interpolated from values</span>
   <span class="c1">// or parametric</span>
   <span class="n">CurveType</span> <span class="n">curve_type</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

   <span class="c1">// The curve group is intended to allow the different</span>
   <span class="c1">// configurations of the same curve to be created for</span>
   <span class="c1">// different use cases, e.g. different interpolation methods</span>
   <span class="c1">// may be used for IM versus VM, or a reduced set of tenors</span>
   <span class="c1">// may be used for computing Liquidity Margin</span>
   <span class="n">CurveGroup</span> <span class="n">curve_group</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

   <span class="n">Currency</span> <span class="n">currency</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

   <span class="n">IndexFamily</span> <span class="n">index_family</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

   <span class="c1">// Tenor is optional; if specified implies a tenor</span>
   <span class="c1">// specific curve</span>
   <span class="n">Tenor</span> <span class="n">tenor</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

   <span class="n">InterpolatorType</span> <span class="n">interpolator_type</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

   <span class="c1">// If interpolated_on is discount factors then it means</span>
   <span class="c1">// that the interpolator should operate on discount factors</span>
   <span class="c1">// rather than zero rates</span>
   <span class="n">IRRateType</span> <span class="n">interpolated_on</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

   <span class="c1">// The maturity generation rule defines how the the bootstrapper</span>
   <span class="c1">// should generate the maturities of the curve</span>
   <span class="n">MaturityGenerationRule</span> <span class="n">maturity_generation_rule</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>

   <span class="c1">// If the curve is defined to have fixed maturity tenors</span>
   <span class="c1">// then a list of tenors is needed</span>
   <span class="c1">// If the maturities are defined from input instruments then</span>
   <span class="c1">// tenors need not be defined</span>
   <span class="n">repeated</span> <span class="n">Tenor</span> <span class="n">tenors</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">ZeroCurve</span> <span class="p">{</span>

   <span class="n">int32</span> <span class="n">curve_definition_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

   <span class="n">repeated</span> <span class="n">int32</span> <span class="n">maturities</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

   <span class="n">repeated</span> <span class="kt">double</span> <span class="n">values</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">ZeroCurveParSensitivities</span> <span class="p">{</span>

   <span class="n">int32</span> <span class="n">curve_definition_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

   <span class="n">int32</span> <span class="n">num_instruments</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

   <span class="n">int32</span> <span class="n">num_maturities</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

   <span class="c1">// Map from &lt;row,col&gt; to value</span>
   <span class="c1">// The lower 16 bits represent the row index</span>
   <span class="c1">// The higher 16 bits represent the column index</span>
   <span class="c1">// We use this format as protobuf requires the map keys to be</span>
   <span class="c1">// integral type</span>
   <span class="n">map</span><span class="o">&lt;</span><span class="n">uint32</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">values</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The API for setting up and using curves is as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Curve identifier</span>
<span class="k">typedef</span> <span class="kt">uint64_t</span> <span class="n">CurveId</span><span class="p">;</span>

<span class="c1">// Constructs a curve id by combining the constituents</span>
<span class="k">extern</span> <span class="n">CurveId</span> <span class="nf">make_curve_id</span><span class="p">(</span><span class="n">PricingCurveType</span> <span class="n">type</span><span class="p">,</span> <span class="n">Currency</span> <span class="n">ccy</span><span class="p">,</span> <span class="n">IndexFamily</span> <span class="n">index_family</span><span class="p">,</span> <span class="n">Tenor</span> <span class="n">tenor</span><span class="p">,</span>
              <span class="n">Date</span> <span class="n">as_of_date</span><span class="p">,</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">cycle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
              <span class="n">MarketDataQualifier</span> <span class="n">qual</span> <span class="o">=</span> <span class="n">MarketDataQualifier</span><span class="o">::</span><span class="n">MDQ_NORMAL</span><span class="p">,</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">scenario</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// Extracts the constituents from a curve id</span>
<span class="k">extern</span> <span class="kt">bool</span> <span class="nf">curve_id_components</span><span class="p">(</span><span class="n">CurveId</span> <span class="n">id</span><span class="p">,</span> <span class="n">PricingCurveType</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="n">Currency</span> <span class="o">&amp;</span><span class="n">ccy</span><span class="p">,</span> <span class="n">IndexFamily</span> <span class="o">&amp;</span><span class="n">index_family</span><span class="p">,</span>
            <span class="n">Tenor</span> <span class="o">&amp;</span><span class="n">tenor</span><span class="p">,</span> <span class="n">Date</span> <span class="o">&amp;</span><span class="n">as_of_date</span><span class="p">,</span> <span class="kt">short</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">cycle</span><span class="p">,</span> <span class="n">MarketDataQualifier</span> <span class="o">&amp;</span><span class="n">qual</span><span class="p">,</span>
            <span class="kt">short</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">scenario</span><span class="p">);</span>

<span class="c1">// Gets a string representation of the curve Id,</span>
<span class="c1">// note that this is an expensive operation so use only for</span>
<span class="c1">// debugging</span>
<span class="k">extern</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">curve_id_to_string</span><span class="p">(</span><span class="n">CurveId</span> <span class="n">id</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">Curve</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">Curve</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">double</span> <span class="nf">time_from_reference</span><span class="p">(</span><span class="n">Date</span> <span class="n">d</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="k">const</span> <span class="n">DayFraction</span> <span class="o">&amp;</span><span class="n">day_fraction</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">Date</span> <span class="nf">as_of_date</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">Date</span> <span class="nf">last_maturity</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">CurveId</span> <span class="nf">id</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">is_valid</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">YieldCurve</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Curve</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">YieldCurve</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">virtual</span> <span class="kt">double</span> <span class="nf">discount</span><span class="p">(</span><span class="kt">double</span> <span class="n">time</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Discount factors</span>
   <span class="c1">// These methods return the discount factor from a given date or time</span>
   <span class="c1">// to the reference date.  In the latter case, the time is calculated</span>
   <span class="c1">// as a fraction of year from the reference date.</span>
   <span class="k">virtual</span> <span class="kt">double</span> <span class="nf">discount</span><span class="p">(</span><span class="n">Date</span> <span class="n">d</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Zero-yield rates</span>
   <span class="c1">// These methods return the implied zero-yield rate for a</span>
   <span class="c1">// given date or time.  In the former case, the time is</span>
   <span class="c1">// calculated as a fraction of year from the reference date.</span>
   <span class="k">virtual</span> <span class="kt">double</span> <span class="nf">zero_rate</span><span class="p">(</span><span class="n">Date</span> <span class="n">d</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// The resulting interest rate has the same day-counting rule</span>
   <span class="c1">// used by the term structure. The same rule should be used</span>
   <span class="c1">// for calculating the passed time t.</span>
   <span class="k">virtual</span> <span class="kt">double</span> <span class="nf">zero_rate</span><span class="p">(</span><span class="kt">double</span> <span class="n">t</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Forward rates</span>
   <span class="c1">// These methods returns the forward interest rate between two dates</span>
   <span class="c1">// or times.  In the former case, times are calculated as fractions</span>
   <span class="c1">// of year from the reference date.</span>
   <span class="c1">// If both dates (times) are equal the instantaneous forward rate is</span>
   <span class="c1">// returned.</span>
   <span class="k">virtual</span> <span class="kt">double</span> <span class="nf">forward_rate</span><span class="p">(</span><span class="n">Date</span> <span class="n">d1</span><span class="p">,</span> <span class="n">Date</span> <span class="n">d2</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// The resulting interest rate has the same day-counting rule</span>
   <span class="c1">// used by the term structure. The same rule should be used</span>
   <span class="c1">// for calculating the passed times t1 and t2.</span>
   <span class="k">virtual</span> <span class="kt">double</span> <span class="nf">forward_rate</span><span class="p">(</span><span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">t2</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Instantaneous forward rate</span>
   <span class="k">virtual</span> <span class="kt">double</span> <span class="nf">forward</span><span class="p">(</span><span class="kt">double</span> <span class="n">t</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Gets the sensitivities to pillars using the underlying</span>
   <span class="c1">// interpolator.</span>
   <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">redukti_adouble_t</span><span class="p">,</span> <span class="n">Deleter</span><span class="o">&lt;</span><span class="n">redukti_adouble_t</span><span class="o">&gt;&gt;</span>
   <span class="n">get_sensitivities</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">FixedRegionAllocator</span> <span class="o">*</span><span class="n">A</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// The offset of the last pillar.</span>
   <span class="c1">// The first pillar is numbered 1.</span>
   <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">last_pillar</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Update the rates</span>
   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">update_rates</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">rates</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Value at pillar point</span>
   <span class="k">virtual</span> <span class="kt">double</span> <span class="nf">value</span><span class="p">(</span><span class="kt">int</span> <span class="n">pillar</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// maturity time from ref date</span>
   <span class="k">virtual</span> <span class="kt">double</span> <span class="nf">maturity_time</span><span class="p">(</span><span class="kt">int</span> <span class="n">pillar</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

   <span class="c1">// maturity date for a pillar</span>
   <span class="k">virtual</span> <span class="n">Date</span> <span class="nf">maturity_date</span><span class="p">(</span><span class="kt">int</span> <span class="n">pillar</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

   <span class="kt">double</span> <span class="nf">last_maturity_time</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">YieldCurve</span><span class="p">,</span> <span class="n">Deleter</span><span class="o">&lt;</span><span class="n">YieldCurve</span><span class="o">&gt;&gt;&gt;</span>
   <span class="n">get_bumped_curves</span><span class="p">(</span><span class="n">Allocator</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="kt">double</span> <span class="n">h</span> <span class="o">=</span> <span class="mf">0.00001</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">YieldCurve</span><span class="p">,</span> <span class="n">Deleter</span><span class="o">&lt;</span><span class="n">YieldCurve</span><span class="o">&gt;&gt;</span> <span class="n">get_bumped_curve</span><span class="p">(</span><span class="n">Allocator</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pillar</span><span class="p">,</span>
                                <span class="kt">double</span> <span class="n">h</span> <span class="o">=</span> <span class="mf">0.00001</span><span class="p">)</span> <span class="k">const</span>
       <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">dump</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">stderr</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">virtual</span> <span class="n">InterpolatorType</span> <span class="nf">interpolator_type</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">};</span>

<span class="c1">// When referencing a curve it is useful to have some</span>
<span class="c1">// indirecton as this allows the curve to be modified without</span>
<span class="c1">// affecting the client code. This is particularly needed when</span>
<span class="c1">// bootstrapping curves. The CurveReference interface provides this</span>
<span class="c1">// indirection.</span>
<span class="k">class</span> <span class="nc">CurveReference</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">CurveReference</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">YieldCurve</span> <span class="o">*</span><span class="nf">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Wraps a curve pointer</span>
<span class="k">class</span> <span class="nc">CurveWrapper</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CurveReference</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">CurveWrapper</span><span class="p">(</span><span class="n">YieldCurve</span> <span class="o">*</span><span class="n">curve</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">YieldCurve</span> <span class="o">*</span><span class="nf">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="n">YieldCurve</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// Construct a curve</span>
<span class="c1">// @param A - Memory allocator</span>
<span class="c1">// @param id - ID of the curve</span>
<span class="c1">// @param as_of_date - As of date</span>
<span class="c1">// @param maturities - Curve pillar points</span>
<span class="c1">// @param values - interpretation depends upon type below</span>
<span class="c1">// @param n - Size of the arrays above</span>
<span class="c1">// @param interpolator - Type of interpolator to be used</span>
<span class="c1">// @param rateType - ZeroRate, DiscountFactor or FowardRate</span>
<span class="c1">// @param derive_order - the order to which node sensitivities are to be</span>
<span class="c1">// computed</span>
<span class="c1">// @fraction - day count fraction</span>
<span class="c1">//</span>
<span class="c1">// Note that the curve object will copy the maturities and values arrays</span>
<span class="c1">// so caller need not retain these arrays. Since the arrays are copied</span>
<span class="c1">// changes to original values do not impact the curve. You can invoke</span>
<span class="c1">// the method update_rates() to update the values after the curve is</span>
<span class="c1">// created.</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">YieldCurve</span><span class="p">,</span> <span class="n">Deleter</span><span class="o">&lt;</span><span class="n">YieldCurve</span><span class="o">&gt;&gt;</span> <span class="n">YieldCurvePointerType</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">YieldCurvePointerType</span> <span class="nf">make_curve</span><span class="p">(</span><span class="n">Allocator</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">CurveId</span> <span class="n">id</span><span class="p">,</span> <span class="n">Date</span> <span class="n">as_of_date</span><span class="p">,</span> <span class="n">Date</span> <span class="n">maturities</span><span class="p">[],</span> <span class="kt">double</span> <span class="n">values</span><span class="p">[],</span>
            <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">InterpolatorType</span> <span class="n">interpolator</span><span class="p">,</span>
            <span class="n">IRRateType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">IRRateType</span><span class="o">::</span><span class="n">ZERO_RATE</span><span class="p">,</span> <span class="kt">int</span> <span class="n">deriv_order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">DayCountFraction</span> <span class="n">fraction</span> <span class="o">=</span> <span class="n">DayCountFraction</span><span class="o">::</span><span class="n">ACT_365_FIXED</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">YieldCurvePointerType</span> <span class="nf">make_svensson_curve</span><span class="p">(</span><span class="n">Allocator</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">CurveId</span> <span class="n">id</span><span class="p">,</span> <span class="n">Date</span> <span class="n">as_of_date</span><span class="p">,</span> <span class="kt">double</span> <span class="n">parameters</span><span class="p">[],</span>
            <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">DayCountFraction</span> <span class="n">fraction</span> <span class="o">=</span> <span class="n">DayCountFraction</span><span class="o">::</span><span class="n">ACT_365_FIXED</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// When constructed this way, inputs are always continuously compounded zero rates. If the curve definition</span>
<span class="c1">// requires interpolation of discount factors then the zero rates are converted to discount factors</span>
<span class="c1">// internally.</span>
<span class="c1">// Note however, that when updating rates, values must be of the correct type - that is,</span>
<span class="c1">// discount factors if that is what is being interpolated on.</span>
<span class="k">extern</span> <span class="n">YieldCurvePointerType</span> <span class="nf">make_curve</span><span class="p">(</span><span class="n">Date</span> <span class="n">as_of_date</span><span class="p">,</span> <span class="k">const</span> <span class="n">IRCurveDefinition</span> <span class="o">*</span><span class="n">defn</span><span class="p">,</span> <span class="k">const</span> <span class="n">ZeroCurve</span> <span class="o">&amp;</span><span class="n">curve</span><span class="p">,</span>
            <span class="kt">int</span> <span class="n">deriv_order</span><span class="p">,</span> <span class="n">PricingCurveType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">PRICING_CURVE_TYPE_UNSPECIFIED</span><span class="p">,</span>
            <span class="n">MarketDataQualifier</span> <span class="n">mdq</span> <span class="o">=</span> <span class="n">MDQ_NORMAL</span><span class="p">,</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">cycle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="kt">short</span> <span class="kt">int</span> <span class="n">scenario</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="time-series-fixings">
<h2>Time Series / Fixings<a class="headerlink" href="#time-series-fixings" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;timeseries.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fixings.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>The timeseries type enables a set of date/value pairs to be managed. Values may be looked up by date. The
API is quite simple:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Value</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">Value</span><span class="p">();</span>
   <span class="n">Value</span><span class="p">(</span><span class="n">Date</span> <span class="n">d</span><span class="p">,</span> <span class="kt">double</span> <span class="n">v</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">);</span>
   <span class="n">Date</span> <span class="nf">date</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="kt">double</span> <span class="nf">value</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">TimeSeries</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">TimeSeries</span><span class="p">();</span>
   <span class="n">TimeSeries</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">num_values</span><span class="p">,</span> <span class="n">Value</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
   <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">num_values</span><span class="p">,</span> <span class="n">Value</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
   <span class="o">~</span><span class="n">TimeSeries</span><span class="p">();</span>
   <span class="n">Value</span> <span class="o">*</span><span class="nf">begin</span><span class="p">();</span>
   <span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="nf">cbegin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="n">Value</span> <span class="o">*</span><span class="nf">end</span><span class="p">();</span>
   <span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="nf">cend</span><span class="p">();</span>
   <span class="kt">bool</span> <span class="nf">find</span><span class="p">(</span><span class="n">Date</span> <span class="n">d</span><span class="p">,</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The fixings service is a type that maintains timeseries data for a bunch of indices and allows values to be looked by
index.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FixingDataService</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">FixingDataService</span><span class="p">();</span>
   <span class="o">~</span><span class="n">FixingDataService</span><span class="p">();</span>

   <span class="kt">void</span> <span class="nf">set_fixings</span><span class="p">(</span><span class="n">IndexId</span> <span class="n">id</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TimeSeries</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">ts</span><span class="p">);</span>
   <span class="n">TimeSeries</span> <span class="o">*</span><span class="nf">get_fixings</span><span class="p">(</span><span class="n">IndexId</span> <span class="n">id</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="cashflows">
<h2>Cashflows<a class="headerlink" href="#cashflows" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cashflows.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>OpenRedukti pricing approach is to convert instruments to cashflows and then price the cashflows. Once an instrument is
represented as a set of cashflows, OpenRedukti does not care what the original representation was.</p>
<p>The client supplies cashflow data in the form of following protocol buffer types:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Simple cashflow (known amount)</span>
<span class="n">message</span> <span class="n">CFSimple</span> <span class="p">{</span>
   <span class="n">Currency</span> <span class="n">currency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

   <span class="kt">double</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

   <span class="c1">// Adjusted payment date</span>
   <span class="n">int32</span> <span class="n">payment_date</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

   <span class="c1">// We need to know the floating rate</span>
   <span class="c1">// index on the trade to determine</span>
   <span class="c1">// the discount curve mapping to use</span>
   <span class="n">IsdaIndex</span> <span class="n">trade_index</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

   <span class="c1">// For fixed rate Bond cashflows</span>
   <span class="c1">// we need to have a direct specification</span>
   <span class="c1">// of the Curve Family (called IndexFamily)</span>
   <span class="c1">// so that we can map to the best discount curve</span>
   <span class="c1">// If this is set this should override</span>
   <span class="c1">// derivation via trade_index above.</span>
   <span class="n">IndexFamily</span> <span class="n">discounting_index_family</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

   <span class="c1">// This is the date following which this</span>
   <span class="c1">// cashflow will not be delivered</span>
   <span class="c1">// Used by bonds</span>
   <span class="c1">// Calculated by taking adjusted payment date</span>
   <span class="c1">// and subtracting ex coupon days offset and then</span>
   <span class="c1">// adusting the date</span>
   <span class="n">int32</span> <span class="n">ex_coupon_date</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// A floating calculation period</span>
<span class="n">message</span> <span class="n">CFFloatingPeriod</span> <span class="p">{</span>
   <span class="kt">double</span> <span class="n">notional</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="kt">double</span> <span class="n">spread</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">accrual_start_date</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">accrual_end_date</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
   <span class="n">IsdaIndex</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
   <span class="n">Tenor</span> <span class="n">tenor</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
   <span class="n">IsdaIndex</span> <span class="n">index2</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
   <span class="n">Tenor</span> <span class="n">tenor2</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Floating Coupon</span>
<span class="c1">// May contain more than one calculation period</span>
<span class="n">message</span> <span class="n">CFFloating</span> <span class="p">{</span>
   <span class="n">Currency</span> <span class="n">currency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

   <span class="n">repeated</span> <span class="n">CFFloatingPeriod</span> <span class="n">floating_periods</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

   <span class="n">CompoundingMethod</span> <span class="n">compounding_method</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

   <span class="n">DayCountFraction</span> <span class="n">day_count_fraction</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

   <span class="n">int32</span> <span class="n">payment_date</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

   <span class="c1">// For floating rate Bond cashflows</span>
   <span class="c1">// we need to have a direct specification</span>
   <span class="c1">// of the Curve Family (called IndexFamily)</span>
   <span class="c1">// so that we can map to the best discount curve</span>
   <span class="c1">// If this is set this should be used to</span>
   <span class="c1">// map the discount curve rather than the</span>
   <span class="c1">// floating rate.</span>
   <span class="n">IndexFamily</span> <span class="n">discounting_index_family</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

   <span class="c1">// This is the date following which this</span>
   <span class="c1">// cashflow will not be delivered</span>
   <span class="c1">// Used by bonds</span>
   <span class="c1">// Calculated by taking adjusted payment date</span>
   <span class="c1">// and subtracting ex coupon days offset and then</span>
   <span class="c1">// adusting the date</span>
   <span class="n">int32</span> <span class="n">ex_coupon_date</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
   <span class="p">}</span>

<span class="c1">// FRA Cashflow</span>
<span class="n">message</span> <span class="n">CFFra</span> <span class="p">{</span>
   <span class="n">Currency</span> <span class="n">currency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="kt">double</span> <span class="n">fixed_rate</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">payment_date</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="n">CFFloatingPeriod</span> <span class="n">floating_period</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
   <span class="n">DayCountFraction</span> <span class="n">day_count_fraction</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OIS cashflow</span>
<span class="n">message</span> <span class="n">CFOis</span> <span class="p">{</span>
   <span class="n">IsdaIndex</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="kt">double</span> <span class="n">notional</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">accrual_start_date</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">accrual_end_date</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">payment_date</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
   <span class="n">DayCountFraction</span> <span class="n">day_count_fraction</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Single cashflow</span>
<span class="c1">// This is a union type</span>
<span class="n">message</span> <span class="n">CFSingle</span> <span class="p">{</span>
   <span class="n">oneof</span> <span class="n">cashflow</span> <span class="p">{</span>
      <span class="n">CFSimple</span> <span class="n">simple</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">CFFloating</span> <span class="n">floating</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
      <span class="n">CFFra</span> <span class="n">fra</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
      <span class="n">CFOis</span> <span class="n">ois</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Cashflow stream</span>
<span class="n">message</span> <span class="n">CFStream</span> <span class="p">{</span>
   <span class="n">repeated</span> <span class="n">CFSingle</span> <span class="n">cashflows</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="c1">// multiplicative factor</span>
   <span class="c1">// typically used to reverse direction using -1.0</span>
   <span class="kt">double</span> <span class="n">factor</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Collection of cashflow streams</span>
<span class="n">message</span> <span class="n">CFCollection</span> <span class="p">{</span>
   <span class="n">repeated</span> <span class="n">CFStream</span> <span class="n">streams</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The external cashflow definition must be converted to an internal representation for pricing. The API for performing this
conversion is described below.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// We separate out the concept of a Cashflow</span>
<span class="c1">// definition (covered here) versus the valuation of</span>
<span class="c1">// cashflows covered in cashflow_pricing.h.</span>

<span class="c1">// The protobuf definition for a Cashflow Collection</span>
<span class="k">class</span> <span class="nc">CFCollection</span><span class="p">;</span>

<span class="c1">// We need a way to refer to logical curve types</span>
<span class="c1">// without having to reference real curves - the PricingCurve</span>
<span class="c1">// helps us do that. Each PricingCurve instance represents</span>
<span class="c1">// a logical identifier for a curve that will be resolved when</span>
<span class="c1">// pricing via a CurveProvider implementation.</span>
<span class="k">class</span> <span class="nc">PricingCurve</span>
<span class="p">{</span>

<span class="k">public</span><span class="o">:</span>
   <span class="c1">// Defaults to 0 which is okay as it maps to unspecified</span>
   <span class="c1">// values component wise</span>
   <span class="n">PricingCurve</span><span class="p">();</span>
   <span class="n">PricingCurve</span><span class="p">(</span><span class="n">PricingCurveType</span> <span class="n">type</span><span class="p">,</span> <span class="n">Currency</span> <span class="n">currency</span><span class="p">,</span> <span class="n">IndexFamily</span> <span class="n">index_family</span> <span class="o">=</span> <span class="n">INDEX_FAMILY_UNSPECIFIED</span><span class="p">,</span>
           <span class="n">Tenor</span> <span class="n">tenor</span> <span class="o">=</span> <span class="n">TENOR_UNSPECIFIED</span><span class="p">);</span>
   <span class="k">explicit</span> <span class="nf">PricingCurve</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">id</span><span class="p">);</span>


   <span class="n">Currency</span> <span class="nf">currency</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="n">IndexFamily</span> <span class="nf">index_family</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="n">Tenor</span> <span class="nf">tenor</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="n">PricingCurveType</span> <span class="nf">curve_type</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="kt">uint32_t</span> <span class="nf">id</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="nf">is_valid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="c1">// Ordering is not meaningful - its purpose is to allow</span>
   <span class="c1">// insertion into containers</span>
   <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">PricingCurve</span> <span class="o">&amp;</span><span class="n">c2</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">PricingCurve</span> <span class="o">&amp;</span><span class="n">c2</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">PricingCurve</span> <span class="o">&amp;</span><span class="n">c2</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="c1">// Get a string representation of the PricingCurve</span>
   <span class="c1">// Note that this is an expensive operation so use only for</span>
   <span class="c1">// debugging</span>
   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Create a PricingCurve with specified type, and currency, index family</span>
<span class="c1">// and tenor taken from the supplied curve Id.</span>
<span class="k">extern</span> <span class="n">PricingCurve</span> <span class="nf">make_pricing_curve</span><span class="p">(</span><span class="n">PricingCurveType</span> <span class="n">type</span><span class="p">,</span> <span class="n">CurveId</span> <span class="n">id</span><span class="p">);</span>

<span class="c1">// When generating cashflows we do not know what actual curves will</span>
<span class="c1">// be used - and whether the forward and discount curves map to the same</span>
<span class="c1">// curve or different curves, or whether different tenor curves map to</span>
<span class="c1">// different curves or the same curve. The CurveMapper allows the caller</span>
<span class="c1">// to provide a mapping to the desired &#39;logical&#39; curve. The mapping is</span>
<span class="c1">// logical so that given a logical curve id, another function must obtain</span>
<span class="c1">// an instance of the real curve.</span>
<span class="k">class</span> <span class="nc">CurveMapper</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">CurveMapper</span><span class="p">();</span>
   <span class="k">virtual</span> <span class="n">PricingCurve</span> <span class="nf">map_index_tenor</span><span class="p">(</span><span class="n">PricingCurveType</span> <span class="n">curve_type</span><span class="p">,</span> <span class="n">Currency</span> <span class="n">currency</span><span class="p">,</span>
                    <span class="n">IndexFamily</span> <span class="n">family</span> <span class="o">=</span> <span class="n">IndexFamily</span><span class="o">::</span><span class="n">INDEX_FAMILY_UNSPECIFIED</span><span class="p">,</span>
                    <span class="n">Tenor</span> <span class="n">tenor</span> <span class="o">=</span> <span class="n">Tenor</span><span class="o">::</span><span class="n">TENOR_UNSPECIFIED</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ValuationContext</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">ValuationContext</span><span class="p">();</span>
   <span class="k">virtual</span> <span class="n">Date</span> <span class="nf">evaluation_date</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="n">Date</span> <span class="nf">payment_cutoff_date</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">derivative_order</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="c1">// include today&#39;s fixing (e.g. eod)</span>
   <span class="c1">// If false then the curve will be used to determine the</span>
   <span class="c1">// rate. The bootstrapper requires this to be false so we set</span>
   <span class="c1">// the default value to false</span>
   <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">include_todays_fixing</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="c1">// Retrieve a fixing.</span>
   <span class="c1">// If the fixing date is &lt; evaluation date then the absence of a fixing</span>
   <span class="c1">// will be an error reported via status. If the fixing date is ==</span>
   <span class="c1">// evaluation date then a missing fixing is not treated as error -</span>
   <span class="c1">// instead the method will return false; in all cases a true return</span>
   <span class="c1">// value indicates that the fixing was found and is set</span>
   <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">get_fixing</span><span class="p">(</span><span class="n">IndexId</span> <span class="n">fixing_key</span><span class="p">,</span> <span class="n">Date</span> <span class="n">fixing_date</span><span class="p">,</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">fixing</span><span class="p">,</span> <span class="n">StatusCode</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cashflows</span><span class="p">;</span>

<span class="c1">// Converts the CFCollection to internal cashflow format</span>
<span class="k">extern</span> <span class="n">Cashflows</span> <span class="o">*</span><span class="nf">construct_cashflows</span><span class="p">(</span><span class="n">RegionAllocator</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="k">const</span> <span class="n">CFCollection</span> <span class="o">*</span><span class="n">cfcollection</span><span class="p">,</span> <span class="k">const</span> <span class="n">ValuationContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">CurveMapper</span> <span class="o">*</span><span class="n">curve_mapper</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="cashflow-pricing">
<h2>Cashflow Pricing<a class="headerlink" href="#cashflow-pricing" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cashflow_pricing.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>Once cashflows are converted to internal format, and Zero Rate / Discount Factor curves are available, you can invoke the
cashflow pricing functions described below.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Sensitivities</span><span class="p">;</span>

<span class="c1">// First order sensitivities (i.e. delta)</span>
<span class="k">struct</span> <span class="n">Sensitivities1D</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">Sensitivities1D</span><span class="p">(</span><span class="k">const</span> <span class="n">CurveReference</span> <span class="o">*</span><span class="n">curve</span><span class="p">,</span> <span class="n">Allocator</span> <span class="o">*</span><span class="n">A</span><span class="p">);</span>
   <span class="o">~</span><span class="n">Sensitivities1D</span><span class="p">();</span>
   <span class="n">YieldCurve</span> <span class="o">*</span><span class="nf">curve</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="kt">double</span> <span class="nf">at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="kt">double</span> <span class="o">&amp;</span><span class="n">at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">);</span>
   <span class="kt">int</span> <span class="nf">count</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Second order sensitivities (i.e. gamma)</span>
<span class="k">struct</span> <span class="n">Sensitivities2D</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">Sensitivities2D</span><span class="p">(</span><span class="k">const</span> <span class="n">CurveReference</span> <span class="o">*</span><span class="n">curve1</span><span class="p">,</span> <span class="k">const</span> <span class="n">CurveReference</span> <span class="o">*</span><span class="n">curve2</span><span class="p">,</span> <span class="n">Allocator</span> <span class="o">*</span><span class="n">A</span><span class="p">);</span>
   <span class="o">~</span><span class="n">Sensitivities2D</span><span class="p">();</span>
   <span class="n">YieldCurve</span> <span class="o">*</span><span class="nf">curve1</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="n">YieldCurve</span> <span class="o">*</span><span class="nf">curve2</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="kt">double</span> <span class="nf">at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">j</span><span class="p">);</span>
   <span class="kt">double</span> <span class="o">&amp;</span><span class="n">at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">j</span><span class="p">);</span>
   <span class="kt">int</span> <span class="nf">count1</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="kt">int</span> <span class="nf">count2</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Sensitivities</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">Sensitivities</span><span class="p">(</span><span class="n">Allocator</span> <span class="o">*</span><span class="n">A</span><span class="p">);</span>
   <span class="o">~</span><span class="n">Sensitivities</span><span class="p">();</span>
   <span class="c1">// Find or add</span>
   <span class="n">Sensitivities1D</span> <span class="o">*</span><span class="nf">first_order_sensitivities</span><span class="p">(</span><span class="n">YieldCurve</span> <span class="o">*</span><span class="n">curve</span><span class="p">);</span>
   <span class="c1">// Find or add</span>
   <span class="n">Sensitivities2D</span> <span class="o">*</span><span class="nf">second_order_sensitivities</span><span class="p">(</span><span class="n">YieldCurve</span> <span class="o">*</span><span class="n">curve1</span><span class="p">,</span> <span class="n">YieldCurve</span> <span class="o">*</span><span class="n">curve2</span><span class="p">);</span>
   <span class="n">Sensitivities1D</span> <span class="o">*</span><span class="nf">find_first_order_sensitivities</span><span class="p">(</span><span class="n">YieldCurve</span> <span class="o">*</span><span class="n">curve</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="n">Sensitivities1D</span> <span class="o">*</span><span class="nf">find_first_order_sensitivities</span><span class="p">(</span><span class="n">CurveId</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="n">Sensitivities2D</span> <span class="o">*</span><span class="nf">find_second_order_sensitivities</span><span class="p">(</span><span class="n">YieldCurve</span> <span class="o">*</span><span class="n">curve1</span><span class="p">,</span> <span class="n">YieldCurve</span> <span class="o">*</span><span class="n">curve2</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="n">Sensitivities2D</span> <span class="o">*</span><span class="nf">find_second_order_sensitivities</span><span class="p">(</span><span class="n">CurveId</span> <span class="n">id1</span><span class="p">,</span> <span class="n">CurveId</span> <span class="n">id2</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

   <span class="kt">void</span> <span class="nf">reset</span><span class="p">();</span>
   <span class="c1">// Find or add</span>
   <span class="k">const</span> <span class="n">CurveReference</span> <span class="o">*</span><span class="nf">get</span><span class="p">(</span><span class="n">YieldCurve</span> <span class="o">*</span><span class="n">curve</span><span class="p">);</span>
   <span class="k">const</span> <span class="n">CurveReference</span> <span class="o">*</span><span class="nf">find</span><span class="p">(</span><span class="n">YieldCurve</span> <span class="o">*</span><span class="n">curve</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="kt">void</span> <span class="nf">get_curve_ids</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CurveId</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">ids</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cashflows</span><span class="p">;</span>

<span class="c1">// Calculate sensitivities (delta and gamma) numerically</span>
<span class="c1">// and store in supplied container</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">compute_sensitivity_numerically</span><span class="p">(</span><span class="n">FixedRegionAllocator</span> <span class="o">*</span><span class="n">allocator</span><span class="p">,</span> <span class="k">const</span> <span class="n">Cashflows</span> <span class="o">*</span><span class="n">flows</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">CurveReference</span> <span class="o">*</span><span class="n">discount_curve</span><span class="p">,</span> <span class="k">const</span> <span class="n">CurveReference</span> <span class="o">*</span><span class="n">forward_curve1</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">CurveReference</span> <span class="o">*</span><span class="n">forward_curve2</span><span class="p">,</span> <span class="n">Sensitivities</span> <span class="o">*</span><span class="n">sensitivities</span><span class="p">,</span>
                   <span class="n">StatusCode</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="kt">double</span> <span class="n">h</span> <span class="o">=</span> <span class="mf">0.00001</span><span class="p">);</span>

<span class="c1">// When cashflows are defined, they reference logical curves via</span>
<span class="c1">// PricingCurve identifiers. At the time of valuation these logical curves</span>
<span class="c1">// must be mapped to physical instances of curves - the CurveProvider</span>
<span class="c1">// interfaces= defines such a component.</span>
<span class="k">class</span> <span class="nc">CurveProvider</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">CurveProvider</span><span class="p">()</span> <span class="p">{}</span>
   <span class="k">virtual</span> <span class="k">const</span> <span class="n">CurveReference</span> <span class="o">*</span><span class="n">get_curve</span><span class="p">(</span><span class="n">PricingCurve</span> <span class="n">curve</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Calculate PV and if ValuationContext.derivative_order &gt; 0</span>
<span class="c1">// then also delta and gamma</span>
<span class="k">extern</span> <span class="kt">double</span> <span class="nf">compute_present_value</span><span class="p">(</span><span class="n">FixedRegionAllocator</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="k">const</span> <span class="n">ValuationContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Cashflows</span> <span class="o">*</span><span class="n">flows</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">CurveProvider</span> <span class="o">*</span><span class="n">mapping_provider</span><span class="p">,</span> <span class="n">Sensitivities</span> <span class="o">&amp;</span><span class="n">sensitivities</span><span class="p">,</span>
                <span class="n">StatusCode</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">double</span> <span class="nf">compute_present_value</span><span class="p">(</span><span class="n">FixedRegionAllocator</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="k">const</span> <span class="n">Cashflows</span> <span class="o">*</span><span class="n">flows</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">CurveReference</span> <span class="o">*</span><span class="n">discount_curve</span><span class="p">,</span> <span class="k">const</span> <span class="n">CurveReference</span> <span class="o">*</span><span class="n">forward_curve1</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">CurveReference</span> <span class="o">*</span><span class="n">forward_curve2</span><span class="p">,</span> <span class="k">const</span> <span class="n">ValuationContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span>
                <span class="n">Sensitivities</span> <span class="o">&amp;</span><span class="n">sensitivities</span><span class="p">,</span> <span class="n">StatusCode</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="curve-building">
<h2>Curve Building<a class="headerlink" href="#curve-building" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;bootstrap.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>Most of the data required to build curves is described in protocol buffers types.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">message</span> <span class="n">ParInstrument</span> <span class="p">{</span>
   <span class="c1">// instrument type is used to decide the pricing algorithm to use</span>
   <span class="n">string</span> <span class="n">instrument_type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="c1">// The instrument_key is a way to identify the instrument</span>
   <span class="c1">// for futures it must be MmmYY where MMM is the expiry month</span>
   <span class="c1">// for Fras its must be nnxnnF</span>
   <span class="n">string</span> <span class="n">instrument_key</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="c1">// A reference to a curve within the owning set</span>
   <span class="n">int32</span> <span class="n">discount_curve_definition_id</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="c1">// A reference to a curve within the owning set</span>
   <span class="n">int32</span> <span class="n">forward_curve_definition_id</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
   <span class="c1">// For instruments that reset on the floating side there</span>
   <span class="c1">// needs to be a floating reset frequency</span>
   <span class="c1">// Only required if different from the curve tenor</span>
   <span class="n">Tenor</span> <span class="n">floating_tenor</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">message</span> <span class="n">ParRates</span> <span class="p">{</span>
   <span class="c1">// We assume that all instrument definitions can be located by</span>
   <span class="c1">// a numeric id - that is given the id there is a way to locate the</span>
   <span class="c1">// instrument, maybe by looking up in a database</span>
   <span class="c1">// Note that the boostrapper does not use these ids</span>
   <span class="n">repeated</span> <span class="n">int32</span> <span class="n">instrument_ids</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">repeated</span> <span class="kt">double</span> <span class="n">values</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">ParCurve</span> <span class="p">{</span>
   <span class="n">int32</span> <span class="n">curve_definition_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">repeated</span> <span class="n">ParInstrument</span> <span class="n">instruments</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="n">ParRates</span> <span class="n">par_rates</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">ParCurveSet</span> <span class="p">{</span>
   <span class="c1">// It is not clear that any meaningful values can be</span>
   <span class="c1">// assigned to ctycle, qualifier or scenario prior to bootstrapping</span>
   <span class="c1">// so these fields probably only make sense afterwards</span>
   <span class="n">int32</span> <span class="n">as_of_date</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">cycle</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="n">MarketDataQualifier</span> <span class="n">qualifier</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">scenario</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
   <span class="n">repeated</span> <span class="n">ParCurve</span> <span class="n">par_curves</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">SolverType</span> <span class="p">{</span>
   <span class="n">SOLVER_TYPE_LEVENBERG_MARQUARDT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">SOLVER_TYPE_LINEAR_LEAST_SQUARE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">SOLVER_TYPE_LINEAR_LUFACTOR</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// The bootstrap request is self contained</span>
<span class="c1">// i.e. all required data must be submitted so that</span>
<span class="c1">// the request can be handled in a stateless manner</span>
<span class="n">message</span> <span class="n">BootstrapCurvesRequest</span> <span class="p">{</span>
   <span class="n">int32</span> <span class="n">business_date</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">repeated</span> <span class="n">IRCurveDefinition</span> <span class="n">curve_definitions</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="n">ParCurveSet</span> <span class="n">par_curve_set</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="c1">// If true will attempt to generate par sensitvities</span>
   <span class="kt">bool</span> <span class="n">generate_par_sensitivities</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
   <span class="n">SolverType</span> <span class="n">solver_type</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">max_solver_iterations</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">BootstrapCurvesReply</span> <span class="p">{</span>
   <span class="n">ReplyHeader</span> <span class="n">header</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">repeated</span> <span class="n">ZeroCurve</span> <span class="n">curves</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="c1">// The sensitivity of zero rates to par rates</span>
   <span class="n">repeated</span> <span class="n">ZeroCurveParSensitivities</span> <span class="n">par_sensitivities</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The API for invoking the curve builder is relatively simple.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CurveBuilderService</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">CurveBuilderService</span><span class="p">();</span>
   <span class="k">virtual</span> <span class="n">BootstrapCurvesReply</span> <span class="o">*</span><span class="nf">handle_bootstrap_request</span><span class="p">(</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">BootstrapCurvesRequest</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">CurveBuilderService</span><span class="o">&gt;</span> <span class="n">get_curve_builder_service</span><span class="p">();</span>
</pre></div>
</div>
<p>The curve building service uses Ravi scripting to define the cashflows for the instruments used in the curve.
To understand how this works, it is necessary to first understand the scripting interface, hence this subject will
be covered in that section.</p>
</div>
<div class="section" id="valuation-service">
<h2>Valuation Service<a class="headerlink" href="#valuation-service" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;valuation.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>The Valuation Service brings together some of the other components of OpenRedukti. It enables deployment of OpenRedukti as
a server. The service accepts all the market data via protocol buffers format messages, and then enables clients to invoke
pricing of cashflows.</p>
<p>The message definitions used by this service are as follows.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">message</span> <span class="n">PricingContext</span> <span class="p">{</span>
   <span class="n">int32</span> <span class="n">as_of_date</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">MarketDataQualifier</span> <span class="n">qualifier</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">cycle</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">payment_cutoff_date</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">derivative_order</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="n">is_todays_fixings_included</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
   <span class="n">CurveGroup</span> <span class="n">curve_group</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
   <span class="c1">// Starting scenario; 0 is the current scenario,</span>
   <span class="c1">// historical scenarios start from 1 and go up.</span>
   <span class="n">int32</span> <span class="n">from_scenario</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">to_scenario</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">SensitivityTypeCode</span> <span class="p">{</span>
   <span class="n">STC_ZERO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">STC_PAR</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">SensitivityOrderCode</span> <span class="p">{</span>
   <span class="n">SOC_DELTA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">SOC_GAMMA</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">SensitivityRiskCode</span> <span class="p">{</span>
   <span class="n">SRC_UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">SRC_FORWARD</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">SRC_DISCOUNT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">IRCurveSensitivities</span> <span class="p">{</span>
   <span class="c1">// Zeror or PAR sensitivities?</span>
   <span class="n">SensitivityTypeCode</span> <span class="n">sensitivity_type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="c1">// Delta or Gamma ?</span>
   <span class="n">SensitivityOrderCode</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="c1">// For each dimension a curve identifier is needed</span>
   <span class="c1">// For delta curves there is only one dimension so only</span>
   <span class="c1">// one curve will be present</span>
   <span class="c1">// Second order sensitivities have two dimensions</span>
   <span class="c1">// -1 if not applicable</span>
   <span class="n">int32</span> <span class="n">curve_definition_id_1</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">curve_definition_id_2</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

   <span class="c1">// For each dimension the type of risk being measured</span>
   <span class="c1">// is required</span>
   <span class="n">SensitivityRiskCode</span> <span class="n">risk_type_1</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
   <span class="n">SensitivityRiskCode</span> <span class="n">risk_type_2</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

   <span class="c1">// Map from &lt;row,col&gt; to value</span>
   <span class="c1">// The lower 32 bits represent the row index</span>
   <span class="c1">// The higher 32 bits represent the column index</span>
   <span class="c1">// We use this format as protobuf requires the map keys to be</span>
   <span class="c1">// integral type</span>
   <span class="n">map</span><span class="o">&lt;</span><span class="n">uint32</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">values</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">ValuationRequest</span> <span class="p">{</span>
   <span class="n">PricingContext</span> <span class="n">pricing_context</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">CFCollection</span> <span class="n">cashflows</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">ValuationResult</span> <span class="p">{</span>
   <span class="c1">// Valuations by scenario</span>
   <span class="n">map</span><span class="o">&lt;</span><span class="n">int32</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">valuations</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="c1">// Sensitivities for scenario 0 only</span>
   <span class="n">repeated</span> <span class="n">IRCurveSensitivities</span> <span class="n">sensitivities</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">ValuationReply</span> <span class="p">{</span>
   <span class="n">ReplyHeader</span> <span class="n">header</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">ValuationResult</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">FixingsByIndexTenor</span> <span class="p">{</span>
   <span class="n">IsdaIndex</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">Tenor</span> <span class="n">tenor</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="c1">// Map of fixing date to fixing value</span>
   <span class="n">map</span><span class="o">&lt;</span><span class="n">int32</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">fixings</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Publish fixings data to the backend</span>
<span class="n">message</span> <span class="n">SetFixingsRequest</span> <span class="p">{</span>
   <span class="n">FixingsByIndexTenor</span> <span class="n">fixings_by_index_tenor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">SetFixingsReply</span> <span class="p">{</span>
   <span class="n">ReplyHeader</span> <span class="n">header</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Publish curve definitions to the backend</span>
<span class="n">message</span> <span class="n">RegisterCurveDefinitionsRequest</span> <span class="p">{</span>
   <span class="n">repeated</span> <span class="n">IRCurveDefinition</span> <span class="n">curve_definitions</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">RegisterCurveDefinitionsReply</span> <span class="p">{</span>
   <span class="n">ReplyHeader</span> <span class="n">header</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Publish zero curves to the backend</span>
<span class="n">message</span> <span class="n">SetZeroCurvesRequest</span> <span class="p">{</span>
   <span class="n">int32</span> <span class="n">as_of_date</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">cycle</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="n">MarketDataQualifier</span> <span class="n">qualifier</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">scenario</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
   <span class="n">CurveGroup</span> <span class="n">curve_group</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
   <span class="n">repeated</span> <span class="n">ZeroCurve</span> <span class="n">forward_curves</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
   <span class="n">repeated</span> <span class="n">ZeroCurve</span> <span class="n">discount_curves</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
   <span class="n">repeated</span> <span class="n">ZeroCurveParSensitivities</span> <span class="n">par_sensitivities</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">SetZeroCurvesReply</span> <span class="p">{</span>
   <span class="n">ReplyHeader</span> <span class="n">header</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// A logical way of identifying a curve</span>
<span class="c1">// Note that curves are assumed to belong to the same</span>
<span class="c1">// context - i.e. business date, curve group,</span>
<span class="c1">// scenario etc.</span>
<span class="n">message</span> <span class="n">PricingCurveIdentifier</span> <span class="p">{</span>
   <span class="n">PricingCurveType</span> <span class="n">type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">Currency</span> <span class="n">currency</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="n">IndexFamily</span> <span class="n">index_family</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="n">Tenor</span> <span class="n">tenor</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This mapping says that whenever the cashflow</span>
<span class="c1">// would have looked for a curve with logical id</span>
<span class="c1">// &#39;from_id&#39; it should use logical curve with &#39;to_id&#39;.</span>
<span class="c1">// Note that the mapping is not recursive, i.e.</span>
<span class="c1">// if &#39;to_id&#39; was mapped also then that would not affect</span>
<span class="c1">// the outcome of mapping &#39;from_id&#39;</span>
<span class="n">message</span> <span class="n">CurveMapping</span> <span class="p">{</span>
   <span class="n">PricingCurveIdentifier</span> <span class="n">from_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">PricingCurveIdentifier</span> <span class="n">to_id</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Before any cashflow valuation can be done</span>
<span class="c1">// one of the pre-requisites is to provide</span>
<span class="c1">// mappings for the logical curves. If a mapping</span>
<span class="c1">// is not provided then the logical curve maps</span>
<span class="c1">// to itself. The aim of the mapping is to allow</span>
<span class="c1">// the cashflow pricer to be unaware of actual curve</span>
<span class="c1">// assignments when performing valuations. Note that the</span>
<span class="c1">// sensitivites are calculated against each logic curve</span>
<span class="c1">// so the mappings affect PV and sensitivities.</span>
<span class="n">message</span> <span class="n">SetCurveMappingsRequest</span> <span class="p">{</span>
   <span class="n">CurveGroup</span> <span class="n">curve_group</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="c1">//PricingCurveType default_curve_type = 2;</span>
   <span class="n">repeated</span> <span class="n">CurveMapping</span> <span class="n">mappings</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">SetCurveMappingsReply</span> <span class="p">{</span>
   <span class="n">ReplyHeader</span> <span class="n">header</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">CurveInterpolationRequest</span> <span class="p">{</span>
   <span class="n">int32</span> <span class="n">business_date</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">IRCurveDefinition</span> <span class="n">definition</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="n">ZeroCurve</span> <span class="n">curve</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="c1">// Specify the rate type for which values are being</span>
   <span class="c1">// requested. If forward rate is requested then</span>
   <span class="c1">// forward_tenor attribute can be set to request a</span>
   <span class="c1">// specific tenor</span>
   <span class="n">IRRateType</span> <span class="n">rate_type</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
   <span class="c1">// If forward rates are requested then</span>
   <span class="c1">// Specify the forward tenor for which forward rates</span>
   <span class="c1">// should be returned; if not specified then the</span>
   <span class="c1">// tenor associated with the index will be returned</span>
   <span class="n">Tenor</span> <span class="n">forward_tenor</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
   <span class="n">repeated</span> <span class="n">int32</span> <span class="n">dates</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">CurveInterpolationReply</span> <span class="p">{</span>
   <span class="n">ReplyHeader</span> <span class="n">header</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">repeated</span> <span class="kt">double</span> <span class="n">values</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The API for interacting with the ValuationService is shown below.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ValuationService</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">ValuationService</span><span class="p">();</span>
   <span class="k">virtual</span> <span class="n">CurveInterpolationReply</span> <span class="o">*</span>
   <span class="nf">handle_curve_interpolation_request</span><span class="p">(</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">CurveInterpolationRequest</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="n">SetCurveMappingsReply</span> <span class="o">*</span><span class="nf">handle_set_curve_mappings_request</span><span class="p">(</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">SetCurveMappingsRequest</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="n">SetZeroCurvesReply</span> <span class="o">*</span><span class="nf">handle_set_zero_curves_request</span><span class="p">(</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">SetZeroCurvesRequest</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="n">RegisterCurveDefinitionsReply</span> <span class="o">*</span>
   <span class="nf">handle_register_curve_definitions_request</span><span class="p">(</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">RegisterCurveDefinitionsRequest</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="n">SetFixingsReply</span> <span class="o">*</span><span class="nf">handle_set_fixings_request</span><span class="p">(</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">SetFixingsRequest</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="n">ValuationReply</span> <span class="o">*</span><span class="nf">handle_valuation_request</span><span class="p">(</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">ValuationRequest</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ValuationService</span><span class="o">&gt;</span> <span class="n">get_valuation_service</span><span class="p">(</span>
   <span class="n">IndexService</span> <span class="o">*</span><span class="n">index_service</span><span class="p">,</span> <span class="n">CalendarService</span> <span class="o">*</span><span class="n">calendar_service</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="requestprocessor">
<h2>RequestProcessor<a class="headerlink" href="#requestprocessor" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;request_processor.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>This implements the request dispatcher that is used in the gRPC server implementation.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RequestProcessor</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">RequestProcessor</span><span class="p">()</span> <span class="p">{}</span>
   <span class="k">virtual</span> <span class="n">Response</span> <span class="o">*</span><span class="n">process</span><span class="p">(</span><span class="k">const</span> <span class="n">Request</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span> <span class="n">Response</span> <span class="o">*</span><span class="n">response</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">set_shutdown_handler</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">funcptr</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Note that the RequestProcessor will take ownership</span>
<span class="c1">// of the CurveBuilderService and ValuationService</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RequestProcessor</span><span class="o">&gt;</span> <span class="n">get_request_processor</span><span class="p">(</span>
   <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">CurveBuilderService</span><span class="o">&gt;</span> <span class="n">bootstrapper</span><span class="p">,</span>
   <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ValuationService</span><span class="o">&gt;</span> <span class="n">valuation_service</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">OpenRedukti</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="openredukti-intro.html">Introduction to OpenRedukti</a></li>
<li class="toctree-l1"><a class="reference internal" href="openredukti-docker-quickstart.html">Quick Start using Docker containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="openredukti-building.html">Building OpenRedukti</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyredukti-intro.html">An Introduction to PyRedukti</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyredukti-api.html">Pything bindings: redukti package</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">OpenRedukti C++ API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#basics">Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#namespace">Namespace</a></li>
<li class="toctree-l2"><a class="reference internal" href="#about-this-document">About this document</a></li>
<li class="toctree-l2"><a class="reference internal" href="#common-enums">Common Enums</a></li>
<li class="toctree-l2"><a class="reference internal" href="#date-type">Date type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#holiday-calendars">Holiday Calendars</a></li>
<li class="toctree-l2"><a class="reference internal" href="#day-count-fractions">Day Count Fractions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#index-types">Index Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#useful-conversions">Useful Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#automatic-differentiation">Automatic Differentiation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#calculation-schedules">Calculation Schedules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memory-allocators">Memory Allocators</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interpolators">Interpolators</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interest-rate-curves">Interest Rate Curves</a></li>
<li class="toctree-l2"><a class="reference internal" href="#time-series-fixings">Time Series / Fixings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cashflows">Cashflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cashflow-pricing">Cashflow Pricing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#curve-building">Curve Building</a></li>
<li class="toctree-l2"><a class="reference internal" href="#valuation-service">Valuation Service</a></li>
<li class="toctree-l2"><a class="reference internal" href="#requestprocessor">RequestProcessor</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="openredukti-ravi-api.html">OpenRedukti Scripting With Ravi</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="pyredukti-api.html" title="previous chapter">Pything bindings: redukti package</a></li>
      <li>Next: <a href="openredukti-ravi-api.html" title="next chapter">OpenRedukti Scripting With Ravi</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Dibyendu Majumdar.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/openredukti-cpp-api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>